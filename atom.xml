<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NingLab</title>
  
  
  <link href="http://ninglab.com/atom.xml" rel="self"/>
  
  <link href="http://ninglab.com/"/>
  <updated>2025-03-23T10:30:56.547Z</updated>
  <id>http://ninglab.com/</id>
  
  <author>
    <name>Ning</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AI-讓-n8n-成為你的天氣小助理</title>
    <link href="http://ninglab.com/AI-%E8%AE%93-n8n-%E6%88%90%E7%82%BA%E4%BD%A0%E7%9A%84%E5%A4%A9%E6%B0%A3%E5%B0%8F%E5%8A%A9%E7%90%86/"/>
    <id>http://ninglab.com/AI-%E8%AE%93-n8n-%E6%88%90%E7%82%BA%E4%BD%A0%E7%9A%84%E5%A4%A9%E6%B0%A3%E5%B0%8F%E5%8A%A9%E7%90%86/</id>
    <published>2025-03-23T10:29:16.000Z</published>
    <updated>2025-03-23T10:30:56.547Z</updated>
    
    <content type="html"><![CDATA[<p>近期 AI 工具使用率越來越廣泛，市面上推出許多方便的 AI 工具</p><p>舉凡一般聊天、查詢知識、製作圖片、翻譯等，讓我們的生活更加輕鬆便利</p><p>使用 n8n 不需要有程式相關知識，想好整個流程，並且學習如何設定就可以輕鬆完成</p><p>今天我們用簡單的範例來教大家如何使用 n8n - 天氣通知</p><p>我們先來列些條件 (中間可自行列條件)</p><ol><li>溫度超過 30 度：炎熱，建議穿輕薄透氣的短袖、短褲或裙子，紫外線強，需要SPF30+防曬霜，戴帽子和太陽眼鏡，注意補充水分。</li><li>溫度低於 30 度，高於 25 度：溫和，建議穿長袖衣物或薄毛衣，可考慮穿長褲，氣溫適中，適合戶外活動。<br>…</li><li>溫度低於 5 度：非常寒冷，需要穿厚重冬衣、保暖內衣、厚外套、圍巾、手套和帽子。</li></ol><h2 id="step-1-至-n8n-官網註冊帳號"><a href="#step-1-至-n8n-官網註冊帳號" class="headerlink" title="step 1. 至 n8n 官網註冊帳號"></a>step 1. 至 n8n 官網註冊帳號</h2><p><a href="https://n8n.io/features/">官方帳號</a> 註冊，註冊帳號後就會有 7 天的免費試用期</p><h4 id="進入到-dashboard-，並且點選-Start-from-scratch"><a href="#進入到-dashboard-，並且點選-Start-from-scratch" class="headerlink" title="進入到 dashboard ，並且點選 Start from scratch"></a>進入到 dashboard ，並且點選 <code>Start from scratch</code></h4><p><img src="https://imgur.com/ynwfSD6.jpg"></p><h4 id="新增第一個步驟，右邊就會出現一排小工具"><a href="#新增第一個步驟，右邊就會出現一排小工具" class="headerlink" title="新增第一個步驟，右邊就會出現一排小工具"></a>新增第一個步驟，右邊就會出現一排小工具</h4><p><img src="https://imgur.com/i2GeGO7.jpg"></p><p><img src="https://imgur.com/KVOacW9.jpg"></p><h2 id="step-2-設定排程"><a href="#step-2-設定排程" class="headerlink" title="step 2. 設定排程"></a>step 2. 設定排程</h2><p>每天出門前先告訴我，今天天氣如何，並且該如何應對</p><p><img src="https://imgur.com/F82wwUi.jpg"></p><ul><li>trigger 觸發器，指的是哪些行為會觸發工作流程，就像是當我們在電商網站下單，有了 <code>下單這個觸發行為</code>，才會有後續的包裝商品、出貨等工作流程</li></ul><p>介紹一下其他的 triggers</p><ol><li><p>Trigger manually (手動觸發) - 這是最基本的觸發方式，手動點擊按鈕才會啟動。</p></li><li><p>On app event (應用事件觸發) - 當連接的第三方應用(如 Gmail、Slack 等)中發生特定事件時觸發。</p></li><li><p>On a schedule (定時觸發) - 根據設定的時間表自動執行，可以設置為每小時、每天、每週等特定時間運行。</p></li><li><p>On webhook call (Webhook 觸發) - 當這個 URL 收到請求時觸發。</p></li></ol><p>5.On form submission (表單觸發) - 處理網頁表單提交的觸發器，當用戶填寫並送出 n8n 生成的表單時觸發。</p><ol start="6"><li><p>When Executed by Another Workflow (由其他工作流執行觸發) - 一個工作流啟動另一個工作流程。</p></li><li><p>On chat message (聊天消息觸發) - 當在連接的聊天平台(如 Slack、Discord 等)收到特定消息或命令時啟動工作流。</p></li><li><p>Other ways… (其他方式) - 各種專門的觸發器，如檔案變更、RSS訂閱更新等特定場景的觸發機制。</p></li></ol><p>點選 <code>On a schedule</code> 後就會有一系列的選項要填</p><ol><li><p>Trigger interval：可選擇以日為單位、以星期為單位，這些都無法滿足你的話，可以嘗試進階客製玩法</p></li><li><p>Days Between Triggers：幾天觸發一次，我這邊選擇每天，所以填寫 1</p></li><li><p>Trigger at Hours: 可選擇幾點觸發，可以設定起床梳妝完成後， 8:00 am 或者 9:00 am 之類的</p></li><li><p>Trigger at Minute: 觸發的分鐘數，選 0 會在整點的時候觸發</p></li></ol><p><img src="https://imgur.com/6pL3DVR.jpg"></p><p>設定完之後就可以點選左上角的 <code>Back to canvas</code> 囉</p><p>這時候畫面會是這樣子</p><p><img src="https://imgur.com/nB3edVc.jpg"></p><p>排成設定完後，我們就要來蒐集天氣資料拉</p><h2 id="step-3-使用天氣偵測工具"><a href="#step-3-使用天氣偵測工具" class="headerlink" title="step 3. 使用天氣偵測工具"></a>step 3. 使用天氣偵測工具</h2><p>為了要搜集到今天的天氣，我們必須依賴外部的天氣預報小工具</p><p>而我在這邊用的工具叫 <code>OpenWeatherMap</code> </p><p><img src="https://imgur.com/yubOkw8.jpg"></p><p>因為要的是今天的天氣，所以選擇 <code>Return current weather data</code></p><p><img src="https://imgur.com/Ic2b1Rs.jpg"></p><p><img src="https://imgur.com/DwU58sD.jpg"></p><p>接著我們要去設定這個工具的 API token</p><p><img src="https://imgur.com/EtKB0rX.jpg"></p><ul><li>API token 就像是一把鑰匙，給你權限讓你可以使用裡面的功能，為什麼需要這個 token 呢？如果沒有這種身份驗證機制，任何人都可以自由使用，而所有的使用量和相關費用都會記在我們自己的帳戶上，可能產生未預期的費用。</li></ul><p>我們先到 <a href="https://openweathermap.org/">OpenWeatherMap</a> 的網站去註冊並且拿取 API key</p><p><img src="https://imgur.com/agf6iZB.jpg"></p><p>點選產生，你的 API Key 就會出現了，出現後就把這串複製起來</p><p><img src="https://imgur.com/t63GLXh.jpg"></p><p>接著回到 n8n ，把這串貼上去並且存檔</p><p><img src="https://imgur.com/4VuPBFg.jpg"></p><p>存檔後就可以設定城市及語系</p><p><img src="https://imgur.com/lFYpIcU.jpg"></p><p>設定後可以點選右上角的 <code>Test step</code> </p><p>如果成功的話會出現結果！（在 <code>main</code> 區塊會有溫度、體感溫度、能見度等資料）</p><p><img src="https://imgur.com/fDVC3Rs.jpg"></p><p>接著點選左上方的 <code>Back to canvas</code></p><p>這邊我們就把天氣設定完成囉</p><p>接下來要幫天氣分類一下</p><h2 id="step-4-天氣分類"><a href="#step-4-天氣分類" class="headerlink" title="step 4. 天氣分類"></a>step 4. 天氣分類</h2><p>怎麼分類呢？我們要先分辨今天的溫度多少</p><p>所以會需要設定判斷式，我們來用最簡單且好懂的 <code>if</code></p><p>拿出剛剛設定的條件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 溫度超過 30 度：炎熱，建議穿輕薄透氣的短袖、短褲或裙子，紫外線強，需要SPF30+防曬霜，戴帽子和太陽眼鏡，注意補充水分。</span><br><span class="line">2. 溫度低於 30 度，高於 25 度：溫暖，適合穿短袖或輕薄長袖，長褲或短褲都可，紫外線開始增強，戶外活動超過30分鐘建議使用SPF15+防曬。。</span><br><span class="line">3. 溫度低於 25 度，高於 20 度：溫和，建議穿長袖衣物或薄毛衣，可考慮穿長褲，氣溫適中，適合戶外活動。</span><br><span class="line">4. 溫度低於 20 度，高於 15 度：涼爽，適合穿輕便外套、長袖衣物和長褲，早晚溫差大，注意增減衣物。</span><br><span class="line">5. 溫度低於 15 度，高於 10 度：寒冷，建議穿保暖外套、毛衣、長褲和保暖配件，注意保暖，特別是頸部和手腳。</span><br><span class="line">6. 溫度低於 10 度，高於 5 度：注意防寒保暖，避免長時間在戶外活動，預防感冒。</span><br><span class="line">7. 溫度低於 5 度：非常寒冷，需要穿厚重冬衣、保暖內衣、厚外套、圍巾、手套和帽子。</span><br></pre></td></tr></table></figure><p>點選 <code>+</code> 的符號</p><p><img src="https://imgur.com/uFE9bf6.jpg"></p><p>在工具列表搜尋 <code>if</code> 並點選</p><p><img src="https://imgur.com/rB5gO6H.jpg"></p><p>因為我們要判斷的是溫度，所以我們可以直接把 <code>temp</code> 給拉過去判斷式，並且設定低於 5</p><p><img src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExeGVrcTlmeWZycWMzbGVrcW93bTlpc2N3MGN2Y2l0Z2R4OWI4cWp6aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/T1UOj0XZrWBgBjzkUu/giphy.gif"></p><p>設定完成後就可以點選 <code>Back to canvas</code> 囉</p><p>這邊我們就完成了一個基本的溫度判斷式，不過我們的條件很多，待會會再示範一個，我們先完成整個流程</p><h2 id="step-5-設定-Email-通知"><a href="#step-5-設定-Email-通知" class="headerlink" title="step 5. 設定 Email 通知"></a>step 5. 設定 Email 通知</h2><p>這邊就會有點小複雜，需要去申請 Google Cloud Platform 的服務</p><h3 id="先到-Google-Cloud-Platform"><a href="#先到-Google-Cloud-Platform" class="headerlink" title="先到 Google Cloud Platform"></a>先到 Google Cloud Platform</h3><p>點進去<a href="https://cloud.google.com/cloud-console?userloc_9197983-network_g">註冊</a></p><p>接著來建立專案，填寫完專案名稱就可以建立專案囉</p><p><img src="https://imgur.com/bJOXVMn.jpg"></p><p><img src="https://imgur.com/I5MxIeK.jpg"></p><p>回到首頁，並且選取剛剛建立的專案</p><p><img src="https://imgur.com/L44vhOB.jpg"></p><p>點進去後就會出現這個畫面</p><p><img src="https://imgur.com/FNHp8Hz.jpg"></p><p>接著我們要來設定 OAuth 同意畫面 (這個畫面就是我們在用 Google 登入其他平台時會出現的授權畫面)</p><p>左上角的漢堡選單，點選 <code>OAuth 同意畫面</code></p><p><img src="https://imgur.com/XzV1mu9.jpg"></p><p><img src="https://imgur.com/stqhb8s.jpg"></p><p>填寫專案資訊</p><ul><li>應用程式名稱可自訂</li><li>電子郵件請填寫你自己的</li></ul><p><img src="https://imgur.com/VMZzWR6.jpg"></p><p>選擇外部（內部我們也沒辦法選）</p><p><img src="https://imgur.com/wEz5cEn.jpg"></p><p>填寫你的聯絡資訊</p><p><img src="https://imgur.com/j2GrUt7.jpg"></p><p>勾選同意後建立</p><p><img src="https://imgur.com/A2QkXy0.jpg"></p><p>接著我們要點選建立 OAUTH 用戶端，讓 Google 知道是哪個平台要存取</p><p><img src="https://imgur.com/hTBJsku.jpg"></p><p>由於我們用的是網頁應用程式 (n8n) ，所以選擇 <code>網頁應用程式</code> </p><p><img src="https://imgur.com/QfpvxpG.jpg"></p><p>接著填寫名稱</p><p>已授權的重新導向 URI 這邊，我們先將這個畫面放旁邊</p><p><img src="https://imgur.com/gqCZEQl.jpg"></p><p>回到 n8n 畫面</p><p><img src="https://imgur.com/zFCRPnx.jpg"></p><p>接著點選 <code>true</code> (就是溫度低於 5 度了，要發送寒冷通知了！)</p><p>沒有低於 5 度就會走 <code>false</code> 那一條</p><p>來設定 Gmail 囉！</p><p><img src="https://imgur.com/fkKAREo.jpg"></p><p>選擇 <code>Send a message</code> （寄信屬於 Send a message 動作，如果有其他想嘗試的，可以看看<a href="https://developers.google.com/gmail/api/guides?hl=zh-tw">官方文件</a>）</p><p><img src="https://imgur.com/7cugPax.jpg"></p><p>選擇 <code>Credential to connect with</code> 並選 <code>Create new credential</code></p><p><img src="https://imgur.com/dzDJYF1.jpg"></p><p>我們這時候就會看到 <code>OAuth Redirect URL</code>，把他複製起來！</p><p>接著回到 Google Cloud Platform</p><p><img src="https://imgur.com/TUnazrX.jpg"></p><p>貼上並且建立 </p><p><img src="https://imgur.com/gqCZEQl.jpg"></p><p>接著點進去該 OAuth</p><p><img src="https://imgur.com/gBt5JFN.jpg"></p><p>複製 <code>Cliend ID</code> 與 <code>Client Secret</code></p><ul><li>Cliend ID 就有點像是登入的帳號，當應用程式跟 Google 進行存取時，會驗證是否有這個 ID</li><li>而 Client Secret 就像是密碼一樣</li></ul><p><img src="https://imgur.com/dfBym4a.jpg"></p><p>回到 n8n 畫面</p><p>分別貼上 <code>Cliend ID</code> 與 <code>Client Secret</code>，並且點選 <code>Sign in with Google</code></p><p><img src="https://imgur.com/KX19c9U.jpg"></p><p>選擇你的帳號</p><p><img src="https://imgur.com/Go4axwZ.jpg"></p><p>接著會出現沒有權限的狀況，這是因為我們沒有設定哪個使用者可以進行測試，如果沒有這個設計，就會變成所有人都可以一直測試，使用服務，最可怕的是賬單爆表</p><p><img src="https://imgur.com/s2Qfeas.jpg"></p><p>所以我們要回到 Google Cloud Platform 設定白名單</p><p>左邊選單，選擇 <code>目標對象</code></p><p><img src="https://imgur.com/sPNJkwk.jpg"></p><p>點選 <code>新增測試使用者</code></p><p><img src="https://imgur.com/iIHBeCG.jpg"></p><p>接著將 email 填上，並儲存</p><p><img src="https://imgur.com/4SMf8nO.jpg"></p><p>我們再回來測試一次</p><p><img src="https://imgur.com/KX19c9U.jpg"></p><p>會跳出授權的功能選單，請點選繼續</p><p><img src="https://imgur.com/UTbwS9B.jpg"></p><p>這邊我會全選，有疑慮的話可選取需要的存取範圍就好，點選後繼續</p><p><img src="https://imgur.com/mcfaXtL.jpg"></p><p>看到這個畫面代表連接成功囉！</p><p><img src="https://imgur.com/RXRUlvJ.jpg"></p><p>接著我們就可以來測試囉</p><p>回到選單，點選兩下 Gmail</p><p><img src="https://imgur.com/oi3NQUd.jpg"></p><p>填寫 <code>收件人</code> <code>主旨</code> <code>內容</code> <code>傳送型態</code></p><p>Resource 為 Message ，可處理信件</p><p>Operation 為 Send ，負責處理寄信</p><p>Email Type 還有支援 HTML </p><p><img src="https://imgur.com/dqVpy1v.jpg"></p><p>填寫完可以點選右上角的 <code>Test step</code></p><p>不過因為我們的條件設定低於 5 度，我當天的溫度高達 26 度</p><p>判斷式會走 false 那條，所以不會寄出任何信，</p><p>所以我們就在 if 的 false 端再加上一個判斷吧！</p><p><img src="https://imgur.com/6mzQjFC.jpg"></p><p>這邊的流程跟剛剛一樣，我就不一一介紹了</p><p>條件是就可以這樣填 (為了 demo ，先填寫今天氣溫符合的條件)</p><p><img src="https://imgur.com/uqdwg1g.jpg"></p><p>接著在 <code>true</code> 加入 Gmail 發送</p><p><img src="https://imgur.com/6mMzY4o.jpg"></p><p>流程也都跟剛剛一樣哦，可以直接這樣設定</p><p><img src="https://imgur.com/s3HagtN.jpg"></p><p>接著可以點選右上角的 <code>Test step</code></p><p>會出現一個奇怪的警告</p><p><img src="https://imgur.com/8rwZJoN.jpg"></p><p>這是因為我們沒有把 Gmail API 的功能開啟</p><p>所以我們去 Google Cloud Platform 把 Gmail API 開啟</p><p><img src="https://imgur.com/j8GC34c.jpg"></p><p><img src="https://imgur.com/nS80uHv.jpg"></p><p>回到 n8n 再來測試一次 <code>Test step</code></p><p>成功就會寄信出去囉！</p><p><img src="https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExenc5OWoxaGJ2MWJ3b3RneWY4N2RxNHkxbzlpbDhhYWIyeWpvZ2JqayZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Cbbv8tj8MwmM5QoqVy/giphy.gif"></p><p><img src="https://imgur.com/SGYDWtq.jpg"></p><p>剩下的天氣條件可自己嘗試玩看看唷！</p><p>如果這篇文章對你有幫助，歡迎點選 <code>Like</code></p><p>如果在嘗試其他條件有問題時，也可以下方留言給我知道哦！</p><p>如果有想使用 n8n 來達成哪些工作流程，也歡迎留言！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期 AI 工具使用率越來越廣泛，市面上推出許多方便的 AI 工具&lt;/p&gt;
&lt;p&gt;舉凡一般聊天、查詢知識、製作圖片、翻譯等，讓我們的生活更加輕鬆便利&lt;/p&gt;
&lt;p&gt;使用 n8n 不需要有程式相關知識，想好整個流程，並且學習如何設定就可以輕鬆完成&lt;/p&gt;
&lt;p&gt;今天我們用簡單</summary>
      
    
    
    
    <category term="AI" scheme="http://ninglab.com/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>成為程式界的 F1 賽車手 - Rust 的 Function 與 Block</title>
    <link href="http://ninglab.com/%E6%88%90%E7%82%BA%E7%A8%8B%E5%BC%8F%E7%95%8C%E7%9A%84-F1-%E8%B3%BD%E8%BB%8A%E6%89%8B-Rust%20%E7%9A%84%20Function-%E8%88%87-Block/"/>
    <id>http://ninglab.com/%E6%88%90%E7%82%BA%E7%A8%8B%E5%BC%8F%E7%95%8C%E7%9A%84-F1-%E8%B3%BD%E8%BB%8A%E6%89%8B-Rust%20%E7%9A%84%20Function-%E8%88%87-Block/</id>
    <published>2024-10-06T13:36:13.000Z</published>
    <updated>2024-10-06T13:56:13.174Z</updated>
    
    <content type="html"><![CDATA[<p>我們在開發的時候，很常會使用到 Function</p><p>大家有想過為什麼要使用 Function 嗎？</p><p>當程式碼開始變多，且開始在不同的地方寫了相同的程式碼之後，我們就會用 Function 把這些相同地方包起來</p><p>對我來說，使用 Function 有幾個不同的意義</p><ol><li>定義輸入值與輸出值的關係（可參考<a href="https://kaochenlong.com/2023/09/22/function.html">龍哥的文章</a>)</li><li>針對該 Function 內的程式碼，賦予名稱意義，使開發者更容易懂</li><li>減少程式碼重複的部分，用 Function 包起來可達成重複使用的效果</li></ol><p>現在我們就來看一下 Rust 中的 Function</p><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>在 Rust 中，Function 以 fn 關鍵字開頭，並有一個名稱、參數和返回值</p><p>這邊我們定義了一個叫做 hello 的 Function</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn hello()&#123;</span><br><span class="line">    println!(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="參數"><a href="#參數" class="headerlink" title="參數"></a>參數</h3><p>剛剛使用 Function 意義有提到， Function 可以定義輸入值與輸出值的關係</p><p>當我們需要用到參數的時候，就代表著有輸入值</p><p>而 Function 回傳的結果則是輸出值</p><p>我們會透過 Function 來讓開發者知道，輸入值與輸出值的關係</p><p>讓我們來看一下該怎麼使用吧</p><p>要注意的是，Function 的參數是需要指定型別的，有助於在編譯的時候就找到錯誤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn calculator(a: i32, b: i32) &#123;</span><br><span class="line">    let result = (a + b) * b;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>每個 Rust 的專案都一定會有 main 這個 Function</p><p>main Function 不能放任何參數(但某些特殊狀況會需要放參數)，也不能有 return 值</p><p>我們可以將 main Function 想像成是專案程式進入點，它會比任何 Function 還優先執行</p><p>因此我們會將 main 作用域以外的 Function 放在 main 裡面呼叫</p><p>以剛剛的例子來看，我們會這樣寫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn calculator(a: i32, b: i32) &#123;</span><br><span class="line">    let result = (a + b) * b;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    calculator(1, 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 6</span><br></pre></td></tr></table></figure><h3 id="return-指定型別"><a href="#return-指定型別" class="headerlink" title="return 指定型別"></a>return 指定型別</h3><p>return 不一定要指定型別，如果沒指定的話，就會是以 <code>()</code> 來代替</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn calculator(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    let result = (a + b) * b;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    calculator(10, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果： 24</span><br></pre></td></tr></table></figure><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>接下來我們就來談談 Rust 的作用域吧！</p><p>每個 block 都是獨立的作用域，我們所定義的變數只會存在於產出他的 block 中，</p><p>function 跟 {} 都算是 block</p><p>讓我們來看看範例吧</p><p>在 {} ，character 被重新賦予值了，所以在 {} 中的 character 就會變成 B</p><p>不過出了這個 block ，就會變回原本的 A</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let character: char = &#x27;A&#x27;;</span><br><span class="line">    &#123;</span><br><span class="line">        let character: char = &#x27;B&#x27;;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, character)</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, character)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">B</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>現在我們知道，Rust 的作用域為一個 block</p><p>在 block 以內就是全新的世界</p><p>這邊我們就必須要提到一個名詞，叫做變數遮蔽 Variable Shadowing</p><p>當我們進入到一個新的 block 時，遇到相同變數，他會蓋掉就有的定義，指向新的定義值</p><p>出了這個 block 後，又會變成原本的值</p><p>讓我們來看看範例</p><p>進入到 block 中， character 就變成了 B 了</p><p>出了 block 後，變成原本的 A</p><p>重新定義就變成了 C</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let character: char = &#x27;A&#x27;;</span><br><span class="line">    &#123;</span><br><span class="line">        let character: char = &#x27;B&#x27;;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, character)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, character);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">B</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>如果想要讓變數不被改，我們可以用 Variable Shadowing 來遮蔽原本的 character 的值，且該變數沒有加上 mut (表示該變數原本就不可變)，所以是不可更改的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let character: char = &#x27;A&#x27;;</span><br><span class="line">    &#123;</span><br><span class="line">        let character = character;</span><br><span class="line"></span><br><span class="line">        character = &#x27;B&#x27;;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, character)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, character)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">error[E0384]: cannot assign twice to immutable variable `character`</span><br><span class="line"> --&gt; src/main.rs:6:9</span><br><span class="line">  |</span><br><span class="line">4 |         let character = character;</span><br><span class="line">  |             ---------</span><br><span class="line">  |             |</span><br><span class="line">  |             first assignment to `character`</span><br><span class="line">  |             help: consider making this binding mutable: `mut character`</span><br><span class="line">5 |</span><br><span class="line">6 |         character = &#x27;B&#x27;;</span><br><span class="line">  |         ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下來來談談匿名函式吧</p><p>匿名函式在 Rust 中就是閉包的概念</p><p>我們先來看閉包是什麼意思</p><p>當作用域中有需要使用到外部作用域的變數時，</p><p>閉包可以向外部作用域拿取該變數進行使用</p><p>引用的方式有三種</p><p>分別為借用(再分成可變與不可變) &#x2F; 轉移所有權</p><p>Rust 會依照狀況來決定要使用哪種方式</p><p>而我們之後也會提到所有權</p><p>舉例來說</p><p>我們在 block 中定義了一個匿名函式，會需要使用到 y 變數</p><p>這時候匿名函式就會去外部作用域抓 y 的值，並進行處理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let y = 10;</span><br><span class="line">    &#123;</span><br><span class="line">        let calculation = |x: i32| &#123;</span><br><span class="line">            let sum = x + y;</span><br><span class="line">            return sum;</span><br><span class="line">        &#125;;</span><br><span class="line">        let sum = calculation(2);</span><br><span class="line">        println!(&quot;the result = &#123;&#125;&quot;, sum)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">the result = 12</span><br></pre></td></tr></table></figure><p>閉包跟函式雖然看起來很像，</p><p>不過閉包並不需要嚴格定義參數型別與回傳值，</p><p>主要是因為，閉包不像函式一樣，是公開使用的，</p><p>且通常都比較簡短，因此 Rust 可以推斷型別</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我們在開發的時候，很常會使用到 Function&lt;/p&gt;
&lt;p&gt;大家有想過為什麼要使用 Function 嗎？&lt;/p&gt;
&lt;p&gt;當程式碼開始變多，且開始在不同的地方寫了相同的程式碼之後，我們就會用 Function 把這些相同地方包起來&lt;/p&gt;
&lt;p&gt;對我來說，使用 Func</summary>
      
    
    
    
    <category term="Rust" scheme="http://ninglab.com/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>用 Rust 來打造你的隨機密碼產生工廠</title>
    <link href="http://ninglab.com/%E7%94%A8-Rust-%E4%BE%86%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E9%9A%A8%E6%A9%9F%E5%AF%86%E7%A2%BC%E7%94%A2%E7%94%9F%E5%B7%A5%E5%BB%A0/"/>
    <id>http://ninglab.com/%E7%94%A8-Rust-%E4%BE%86%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E9%9A%A8%E6%A9%9F%E5%AF%86%E7%A2%BC%E7%94%A2%E7%94%9F%E5%B7%A5%E5%BB%A0/</id>
    <published>2024-09-12T18:08:31.000Z</published>
    <updated>2024-09-13T01:49:44.421Z</updated>
    
    <content type="html"><![CDATA[<p>在 stack overflow 的 2024 年調查中， Rust 被列為最讚賞的語言之一</p><p>Rust 的高效能特性，讓許多的工具都掀起以 Rust 的改寫風潮</p><p>這次我們會用 Rust 來做一個工具，讓大家體驗用 Rust 開發的樂趣</p><h3 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h3><ul><li>安裝 Rust</li><li>可參考<a href="https://github.com/cacachang/password_generator">專案成果</a></li></ul><h3 id="step-0-用-Cargo-新增專案"><a href="#step-0-用-Cargo-新增專案" class="headerlink" title="step 0. 用 Cargo 新增專案"></a>step 0. 用 Cargo 新增專案</h3><p>Cargo 是 Rust 的套件管理工具，我們可以用 Cargo 來新增專案，也可以用它來編譯 Rust 檔案以及執行</p><ul><li>新增專案</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new password_generator</span><br></pre></td></tr></table></figure><p>當我們要編譯 Rust 專案時，就可以下該指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure><p>但如果是編譯加上執行專案的話，就可以改以下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><h3 id="Step-1-打造-CLI"><a href="#Step-1-打造-CLI" class="headerlink" title="Step 1. 打造 CLI"></a>Step 1. 打造 CLI</h3><p>首先，我們要來打造 CLI ，來創造使用者與程式互動的介面</p><p>我們會用一個套件，叫做 <code>inquire</code> 來做出 CLI</p><p>第一次加套件，就先用手動的方式來加入吧！</p><p>Cargo.toml 檔案中不只是放置檔案的基本資料，也會放套件的資訊哦！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Cargo.toml</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">inquire = &quot;0.7.5&quot;</span><br></pre></td></tr></table></figure><p>這個套件有支援很多種輸入方式，有包含以下：</p><ul><li>文字輸入</li><li>日期選擇</li><li>選擇題</li><li>複選題</li></ul><p>有興趣的話可直接進入到該套件的 <a href="https://github.com/mikaelmello/inquire?tab=readme-ov-file">github</a> 看看</p><p>接著我們來設定密碼的長度</p><h3 id="Step-2-1-設定密碼長度"><a href="#Step-2-1-設定密碼長度" class="headerlink" title="Step 2 - 1. 設定密碼長度"></a>Step 2 - 1. 設定密碼長度</h3><p>我們要先到 <code>main.rs</code> 檔案中，</p><h4 id="main-rs"><a href="#main-rs" class="headerlink" title="main.rs"></a>main.rs</h4><p>每一個 Rust 專案都必須要有 main.rs 檔案，</p><p>我們可以把 main.rs 當作是一個進入點，</p><p>main.rs 有幾個特性</p><ul><li>沒有參數</li><li>不會有 return 值</li></ul><p>介紹完 main.rs 後，我們就來設定密碼長度吧！</p><p>由使用者自行決定密碼長度相對彈性，</p><p>因此我們會使用套件的文字輸入，讓使用者自行輸入需要的密碼長度</p><p>在使用 Text 模組前，我們要在檔案上面使用 <code>use</code> 來載入該套件的 Text 模組，並且做出文字輸入的問題</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># main.rs</span><br><span class="line">use inquire::Text;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let length_ans = Text::new(&quot;請問您的密碼長度要設定多少？&quot;).prompt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定義變數"><a href="#定義變數" class="headerlink" title="定義變數"></a>定義變數</h4><p>這邊要跟大家提一下，在 Rust 中的變數定義需要用 let 或者 const </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let number_one = “1”</span><br><span class="line">const number_two = “2”</span><br></pre></td></tr></table></figure><p>跟 JavaScript 一樣， let 是可以做更改的， const 是不能做更改的</p><p>如果要讓該變數的值可以更改，我們就必須這樣用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mut number = “1234”</span><br></pre></td></tr></table></figure><h4 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h4><p>我們在使用 <code>Text::new</code> 模組中的 <code>prompt</code> 方法時，會回傳一個 <code>Result</code> 型態的值</p><p><code>Result</code> 是 Error Handling 的一種</p><p>當我們需要判斷程式結果時，就可以使用 <code>Error Handling</code></p><p><code>Error Handling</code> 分為 <code>可復原的</code> 以及 <code>不可復原的</code></p><p>可復原的為 <code>Result</code> 與 <code>Option</code></p><p><code>Result&lt;T, E&gt;</code> 來表示結果是成功還是失敗，需要兩個參數，一個是 T，一個是 E，其實這兩個參數是</p><p>T 代表著成功後回傳的變數<br>E 則是失敗回傳的錯誤訊息</p><p>來個小範例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let number: Result&lt;i32, _&gt; = &quot;123&quot;.parse();</span><br><span class="line"></span><br><span class="line">    match number &#123;</span><br><span class="line">        Ok(num) =&gt; println!(&quot;解析成功：&#123;&#125;&quot;, num),</span><br><span class="line">        Err(error) =&gt; println!(&quot;無法解析：&#123;&#125;&quot;, error),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Option&lt;T&gt;</code> 適用於此變數或者結果是否存在，會有 None 以及 Some 這兩個結果</p><p>這邊的 T 跟 Result 不太一樣，可能會是 Some 或者是 None，不過他們都是參數</p><p>Some(c) 表示存在，並且回傳 c 變數(不一定要叫 c ，想叫什麼都可)<br>None 表示不存在</p><p>來個小範例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [1, 2, 3];</span><br><span class="line">    let b = a.get(2);</span><br><span class="line"></span><br><span class="line">    let _c = match b &#123;</span><br><span class="line">        None =&gt; println!(&quot;沒有這個值&quot;),</span><br><span class="line">        Some(c) =&gt; println!(&quot;結果為：&#123;&#125;&quot;, c),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以他們用法上會有一些差別</p><h4 id="print"><a href="#print" class="headerlink" title="print"></a>print</h4><p>接著我們來介紹在 Rust 中要怎麼把東西印出來</p><p>如果是要印一般的字串，其實蠻簡單的，用下方寫法就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println!(&quot;我是 Rust 我最棒！&quot;)</span><br></pre></td></tr></table></figure><p>但如果是要印出變數，我們就必須使用 <code>&#123;:?&#125;</code> ，來看一下用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let language = &quot;Rust&quot;;</span><br><span class="line">println!(&quot;我是 &#123;&#125;&quot;, language)</span><br><span class="line"></span><br><span class="line">// 我是 Rust</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let language = [&quot;Rust&quot;, &quot;Ruby&quot;]</span><br><span class="line">println!(&quot;&#123;:?&#125;&quot;, language)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// [&quot;Rust&quot;, &quot;Ruby&quot;]</span><br></pre></td></tr></table></figure><p>用文字輸入做出密碼長度的問題後，</p><p>我們還要再去定義密碼長度的變數，</p><p>因為使用 <code>Text::new(&quot;請問您的密碼長度要設定多少？&quot;).prompt()</code> 做出來的會是一個 <code>Result</code>，</p><p>之後要產生密碼是需要抓數字來判斷長度要多少，</p><p>所以我們可以要另外定義<br>( 預設可給 8，如果使用者輸入的值不是 8 ，就得改變，所以要給 <code>mut</code> )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    let mut length = 8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到這邊，我們就把密碼長度設定好了！</p><p>大家可以在終端機下 <code>cargo run</code> 來試試是否跳出 CLI</p><p>如果成功的話，我們就進行下一步吧！來判斷使用者所輸入的答案</p><h3 id="Step-2-2-設定密碼長度-判斷輸入的文字"><a href="#Step-2-2-設定密碼長度-判斷輸入的文字" class="headerlink" title="Step 2 - 2. 設定密碼長度 - 判斷輸入的文字"></a>Step 2 - 2. 設定密碼長度 - 判斷輸入的文字</h3><p>在 Rust 中，判斷變數符合哪個情況，可以使用 <code>match</code></p><p><code>match</code> 類似 JavaScript 中的 switch </p><p>會依照值符合哪個狀況來執行不同的程式碼</p><p>假設 <code>length_ans</code> 是沒有錯誤的，那我們就去解析是否為數字</p><p>如果是數字，那就顯示設定的密碼長度為多少，並且將 length 重新賦值</p><p>如果不符合數字，那就會顯示 <code>您輸入的不是有效的整數</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    match length_ans &#123;</span><br><span class="line">        Ok(length_ans) =&gt; match length_ans.parse::&lt;i32&gt;() &#123;</span><br><span class="line">            Ok(number) =&gt; &#123;</span><br><span class="line">                println!(&quot;設定的密碼長度為: &#123;&#125;&quot;, number);</span><br><span class="line">                length = number;</span><br><span class="line">            &#125;</span><br><span class="line">            Err(_) =&gt; &#123;</span><br><span class="line">                println!(&quot;您輸入的不是有效的整數&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        Err(_) =&gt; &#123;</span><br><span class="line">            println!(&quot;請輸入密碼長度&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>設定完後，就可以輸入 <code>cargo run</code> 來試試執行結果！</p><h3 id="Step-3-定義密碼範本變數"><a href="#Step-3-定義密碼範本變數" class="headerlink" title="Step 3. 定義密碼範本變數"></a>Step 3. 定義密碼範本變數</h3><p>我們會從密碼範本中產出隨機碼做成密碼，<br>由於密碼範本可能會更改，所以我們要讓他是 <code>mut</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    let mut charset = String::from(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-4-1-是否包含數字-定義密碼的數字範本變數"><a href="#Step-4-1-是否包含數字-定義密碼的數字範本變數" class="headerlink" title="Step 4 - 1. 是否包含數字 - 定義密碼的數字範本變數"></a>Step 4 - 1. 是否包含數字 - 定義密碼的數字範本變數</h3><p>在判斷是否包含數字以前，我們先將數字的密碼範本定義好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    const PASSWORD_NUMBER: &amp;str = &quot;1234567890&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="str"><a href="#str" class="headerlink" title="&amp;str"></a>&amp;str</h4><p>在這邊我們看到了一個陌生的型態 <code>&amp;str</code> </p><p>它叫做字串切片，顧名思義就是從字串切下來的一段字</p><p>要注意的是，他與字串是不一樣的喔</p><p>字串切片是不能被更改的</p><h3 id="Step-4-2-是否包含數字-密碼是否包含數字"><a href="#Step-4-2-是否包含數字-密碼是否包含數字" class="headerlink" title="Step 4 - 2. 是否包含數字 - 密碼是否包含數字"></a>Step 4 - 2. 是否包含數字 - 密碼是否包含數字</h3><p>這次我們會用選擇題來讓使用者回答，密碼是否要包含數字</p><p>所以我們會使用到 <code>Confirm</code> 模組</p><p><code>with_default</code> 可以讓你建立預設值，假設使用者直接按 <code>enter</code> 下去，他就會直接帶入預設值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use inquire::&#123;Confirm, Text&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    let contain_number = Confirm::new(&quot;密碼是否包含數字&quot;).with_default(true).prompt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-4-3-是否包含數字-判斷輸入的答案"><a href="#Step-4-3-是否包含數字-判斷輸入的答案" class="headerlink" title="Step 4 - 3. 是否包含數字 - 判斷輸入的答案"></a>Step 4 - 3. 是否包含數字 - 判斷輸入的答案</h3><p>一樣我們會用 <code>match</code> 來判斷狀況，並且透過 <code>Result</code> 來判斷程式碼是否有誤</p><p>假設沒有錯誤，就會印出 <code>你的密碼將包含數字</code></p><p>且將 <code>數字範本</code> 塞入 <code>密碼範本</code> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    match contain_number &#123;</span><br><span class="line">        Ok(contain_number) =&gt; &#123;</span><br><span class="line">            if contain_number &#123;</span><br><span class="line">                println!(&quot;你的密碼將包含數字&quot;);</span><br><span class="line">                charset.push_str(PASSWORD_NUMBER)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                println!(&quot;你的密碼不包含數字&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Err(_) =&gt; println!(&quot;請選擇是否包含數字&quot;),</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Step-5-1-密碼是否包含字元-符號-定義密碼的字元-符號範本變數"><a href="#Step-5-1-密碼是否包含字元-符號-定義密碼的字元-符號範本變數" class="headerlink" title="Step 5 - 1. 密碼是否包含字元 &#x2F; 符號 - 定義密碼的字元 &#x2F; 符號範本變數"></a>Step 5 - 1. 密碼是否包含字元 &#x2F; 符號 - 定義密碼的字元 &#x2F; 符號範本變數</h3><p>在設定是否要讓密碼包含字元 &#x2F; 符號前，</p><p>我們也先來定義 字元 &#x2F; 符號 的密碼範本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    const PASSWORD_LOWERCASE: &amp;str = &quot;abcdefghijklmnopqrstuvwxyz&quot;;</span><br><span class="line">    const PASSWORD_UPPERCASE: &amp;str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;</span><br><span class="line">    const PASSWORD_SYMBOL: &amp;str = &quot;!@#$%^&amp;*()_+-=[]&#123;&#125;|;:&#x27;,.&lt;&gt;?&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-5-2-密碼是否包含字元-符號-複選題"><a href="#Step-5-2-密碼是否包含字元-符號-複選題" class="headerlink" title="Step 5 - 2. 密碼是否包含字元 &#x2F; 符號 - 複選題"></a>Step 5 - 2. 密碼是否包含字元 &#x2F; 符號 - 複選題</h3><p>接著我們會讓使用者用複選的方式來看是否要包含大小寫英文字母 還是 符號</p><p>我們會需要用到 <code>MultiSelect</code> 模組</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use inquire::&#123;Text, Confirm, MultiSelect&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    let options = vec![&quot;lowercase&quot;, &quot;uppercase&quot;, &quot;symbol&quot;];</span><br><span class="line">    let char_ans = MultiSelect::new(&quot;請選擇密碼是否要包含:&quot;, options).prompt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector 是一種存放資料的集合型別，在 Rust 中是屬於標準函式庫型別，</p><p>放置在同一個 Vector 裡面的資料都是要一樣型態的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let collection = vec![1, 2, 3, 4];</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><h3 id="Step-5-3-密碼是否包含字元-符號-判斷輸入的答案"><a href="#Step-5-3-密碼是否包含字元-符號-判斷輸入的答案" class="headerlink" title="Step 5 - 3. 密碼是否包含字元 &#x2F; 符號 - 判斷輸入的答案"></a>Step 5 - 3. 密碼是否包含字元 &#x2F; 符號 - 判斷輸入的答案</h3><p>一樣是透過 <code>match</code> 來判斷 char_ans </p><p>比較特別的是， <code>choice</code> 會是一個 <code>Vector</code>，因此我們需要用 <code>for ... in</code> 將裡面的答案一個個拿出來比對，</p><p>如果有 match 到大寫英文，我們就將大寫英文範本塞進去密碼範本中</p><p>match 選項最後有個 <code>_</code> ，這表示如果沒有到 match 上述的任何一個，就會走這條</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    match char_ans &#123;</span><br><span class="line">        Ok(choices) =&gt; &#123;</span><br><span class="line">            for choice in choices &#123;</span><br><span class="line">                match choice &#123;</span><br><span class="line">                    &quot;lowercase&quot; =&gt; charset.push_str(PASSWORD_LOWERCASE),</span><br><span class="line">                    &quot;uppercase&quot; =&gt; charset.push_str(PASSWORD_UPPERCASE),</span><br><span class="line">                    &quot;symbol&quot; =&gt; charset.push_str(PASSWORD_SYMBOL),</span><br><span class="line">                    _ =&gt; (),</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Err(_) =&gt; println!(&quot;選擇出現錯誤&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-6-1-產生隨機碼-安裝套件"><a href="#Step-6-1-產生隨機碼-安裝套件" class="headerlink" title="Step 6 - 1. 產生隨機碼 - 安裝套件"></a>Step 6 - 1. 產生隨機碼 - 安裝套件</h3><p>接著我們需要用密碼範本來隨機產生</p><p>所以我們會需要用到 <code>Rand</code> 這個套件，</p><p>這個套件可以讓我們隨機產生數字，</p><p>所以直接下 <code>cargo add rand</code></p><p>就會自動在 Cargo.toml 中加上 <code>rand = &quot;0.8.5&quot;</code> 了</p><h3 id="Step-6-2-產生隨機碼-產出密碼"><a href="#Step-6-2-產生隨機碼-產出密碼" class="headerlink" title="Step 6 - 2. 產生隨機碼 - 產出密碼"></a>Step 6 - 2. 產生隨機碼 - 產出密碼</h3><p>這邊我們會使用到 rand 的 Rng 模組，</p><p>我們會透過 <code>rand::thread_rng()</code> 來產生隨機數字</p><p>會先將密碼範本中的每個字或者數字轉成 u8 格式，並且集合成一個陣列，<code>char_bytes</code> 會指向這個陣列</p><p>接著我們會由 0 ~ 密碼長度依序隨機抓出一個 index</p><p>最後在 <code>char_byte</code> 取出該 index 的值，並且轉為 <code>字元</code> 格式</p><p>最後將他們集合起來成為密碼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use rand::Rng;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut rng = rand::thread_rng();</span><br><span class="line">    let char_bytes: &amp;[u8] = charset.as_bytes();</span><br><span class="line">    let password: String = (0..length).map(|_| &#123;</span><br><span class="line">        let idx = rng.gen_range(0..char_bytes.len());</span><br><span class="line">        char_bytes[idx] as char</span><br><span class="line">    &#125;).collect();</span><br><span class="line"></span><br><span class="line">    println!(&quot;您的密碼為：&#123;:?&#125;&quot;, password)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="u8"><a href="#u8" class="headerlink" title="u8"></a>u8</h4><p>為正數的數字，不包含負數，u 是指 <code>unsigned</code> ， 8 則是指 8-bit</p><h4 id="字元"><a href="#字元" class="headerlink" title="字元"></a>字元</h4><p>我們可以定義任何符號，甚至是數字為字元，型別設定為 char 即可<br>但只能放一個字，後面務必要用單引號</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let money: char = &#x27;$&#x27;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, money);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果： $</span><br></pre></td></tr></table></figure><h3 id="Step-6-3-包成方法"><a href="#Step-6-3-包成方法" class="headerlink" title="Step 6 - 3. 包成方法"></a>Step 6 - 3. 包成方法</h3><p>待會要去判斷密碼中是否包含數字(常出現結果沒有數字)，所以隨機產生密碼的方法會重複使用</p><p>所以就來把他包成一個方法，記得要把它放在 main 方法外面，並且回傳為一個 <code>String</code> 字串格式</p><p>而剛剛放在 main 方法中的隨機產生碼就可以先刪除了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn generate_password(charset: &amp;str, length: i32) -&gt; String &#123;</span><br><span class="line">    let mut rng = rand::thread_rng();</span><br><span class="line">    let char_bytes: &amp;[u8] = charset.as_bytes();</span><br><span class="line"></span><br><span class="line">    let result = (0..length)</span><br><span class="line">        .map(|_| &#123;</span><br><span class="line">            let idx = rng.gen_range(0..char_bytes.len());</span><br><span class="line">            char_bytes[idx] as char</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect();</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4><p>當 function 會需要參數的時候，必須要將型別定義清楚，就像上方的 <code>charset: &amp;str</code> &#x2F; <code>length: i32</code> 一樣，</p><p>如果有回傳值，也必須要定義好型態，以上方例子來說，會回傳一個 String 型態</p><h3 id="Step-7-1-密碼未包含數字，就重來"><a href="#Step-7-1-密碼未包含數字，就重來" class="headerlink" title="Step 7 - 1. 密碼未包含數字，就重來"></a>Step 7 - 1. 密碼未包含數字，就重來</h3><p>沒有說要包含數字的話，我們就直接將產生密碼，不需要再做檢查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    let mut password = generate_password(&amp;charset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著必須先判斷使用者有沒有說要包含數字</p><p>所以一樣用 <code>match</code> 與 <code>Result</code> 去判斷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    match contain_number &#123;</span><br><span class="line">        Ok(contain) =&gt; &#123;</span><br><span class="line">            if contain &#123;</span><br><span class="line">                ... </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Err(_) =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有包含數字的話，就必須要去跑 loop 檢查是否有數字，沒有就重新產生，並且重新賦值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    match contain_number &#123;</span><br><span class="line">        Ok(contain) =&gt; &#123;</span><br><span class="line">            if contain &#123;</span><br><span class="line">                loop &#123;</span><br><span class="line">                    let origin_result = generate_password(&amp;charset, length);</span><br><span class="line">                    if origin_result.chars().any(|a| a.is_digit(10)) &#123;</span><br><span class="line">                        password = origin_result;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Err(_) =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;您的密碼為：&#123;:?&#125;&quot;, password)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就完成密碼產生器囉！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 stack overflow 的 2024 年調查中， Rust 被列為最讚賞的語言之一&lt;/p&gt;
&lt;p&gt;Rust 的高效能特性，讓許多的工具都掀起以 Rust 的改寫風潮&lt;/p&gt;
&lt;p&gt;這次我們會用 Rust 來做一個工具，讓大家體驗用 Rust 開發的樂趣&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Rust" scheme="http://ninglab.com/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>輕量化前端組合技： htmx 與 Alpine.js 開發應用</title>
    <link href="http://ninglab.com/%E8%BC%95%E9%87%8F%E5%8C%96%E5%89%8D%E7%AB%AF%E7%B5%84%E5%90%88%E6%8A%80%EF%BC%9A-htmx-%E8%88%87-Alpine-js-%E9%96%8B%E7%99%BC%E6%87%89%E7%94%A8/"/>
    <id>http://ninglab.com/%E8%BC%95%E9%87%8F%E5%8C%96%E5%89%8D%E7%AB%AF%E7%B5%84%E5%90%88%E6%8A%80%EF%BC%9A-htmx-%E8%88%87-Alpine-js-%E9%96%8B%E7%99%BC%E6%87%89%E7%94%A8/</id>
    <published>2024-09-08T19:09:47.000Z</published>
    <updated>2024-09-11T04:00:04.025Z</updated>
    
    <content type="html"><![CDATA[<p>身為後端工程師，在處理前端的時候，</p><p>不是要去學框架就是要用純 JavaScript ，</p><p>在 Ruby on Rails 有 Hotwire 與 Stimulus.js，</p><p>可以輕鬆達到即時渲染及前端互動的效果，</p><p>不過在其他框架就沒有這麼簡單，</p><p>htmx 的出現，可以省去後端工程師打 API &#x2F; 做即時渲染的繁複程序</p><p>而前端互動效果，就可以交給 Alpine.js</p><p>兩者搭配起來，寫出基本的前端功能並不是難事</p><p>今天就要來介紹這兩個工具如何使用</p><h3 id="htmx"><a href="#htmx" class="headerlink" title="htmx"></a>htmx</h3><p>在 HTML 中，僅有支援 <code>GET</code> 與 <code>POST</code> 方法</p><p>當我們用純 HTML 來發送 request 為 POST 方法的話，會是這樣寫</p><p>並且只有 <code>form</code> 表單才能送 <code>POST</code> 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>一般的 a 標籤只能發送 <code>GET</code> 方法</p><p>如果我們要遵守 RESTful API 的規範，要使用 PUT &#x2F; PATCH &#x2F; DELETE 這些方法</p><p>就必須要另外抓 DOM 元素 &#x2F; 監聽事件 &#x2F; 打 API ，</p><p>甚至還必須處理 JSON 格式的資料</p><p>一個畫面可能不是只處理一個，可能是好幾十個，這時候就會很頭痛</p><p>為了解決這個問題， htmx 讓我們除了透過 attribute 用 POST &#x2F; GET 方法</p><p>還可以使用其他的 HTTP 方法，例如 PUT &#x2F; PATCH &#x2F; DELETE 等來發送 request</p><p>接著有另外一個問題是，當我們發送 request 出去時，頁面會重整換掉，</p><p>如果今天老闆希望我們做的是點下按鈕就即時渲染，</p><p>就必須透過 AJAX 來做，</p><p>不過透過 AJAX ，還是得抓 DOM 元素 &#x2F; 監聽事件 &#x2F; 非同步方式打 API ，</p><p>累積下來也是要耗不少工， htmx 在發送 request 的時候都是採用 AJAX 方式，</p><p>所以我們就不需要這麼辛苦了</p><ul><li>AJAX</li></ul><p>AJAX 的全名為 Asynchronous JavaScript and XML ，這些字詞的意思為 非同步 JavaScript 與 XML</p><p>非同步 JavaScript 大家應該都不陌生，指的是不需要等待上一個任務執行完再執行下一個，因此系統同時可以處理多個任務</p><p>而 AJAX 使用 XMLHttpRequest 來發送 Request，格式是採用 XML 格式</p><p>回傳的 Response 可以採用 XML 或者是 JSON ，現階段大多以 JSON 格式回傳</p><p><img src="https://i.imgur.com/vxXZ5xN.jpeg"></p><p>如此一來，就能馬上渲染資料</p><h3 id="Alpine-js"><a href="#Alpine-js" class="headerlink" title="Alpine.js"></a>Alpine.js</h3><p>當我們在全端框架時，偶爾會需要做出前端互動效果，</p><p>這時候通常都會使用前端框架來達成，</p><p>不過如果只是簡單的互動效果，不使用框架，寫單純的 JavaScript ，光是抓 DOM 元素就會抓到頭痛</p><p>Alpine.js 是一款輕量的 JavaScript 框架</p><p>我們可以透過 HTML attribute 來輕鬆抓到 DOM 元素</p><p>再透過其他的 HTML attribute 來達成互動效果</p><p>不僅增添工程師使用上的便利性，也省去了學習前端框架的成本</p><p>說了這麼多優點，直接實作會讓大家更了解便利處</p><h3 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h3><ul><li>已安裝 Python</li><li>已安裝 Poetry</li></ul><h3 id="clone-專案"><a href="#clone-專案" class="headerlink" title="clone 專案"></a>clone 專案</h3><p>這次會帶大家做一次 Todo List </p><p>可直接 clone 已做好 CRUD 的專案</p><p><code>https://github.com/cacachang/django-todo</code></p><p>clone 下來後，記得做幾個步驟：</p><ul><li>poetry shell 進入虛擬環境</li><li>poetry install 安裝套件</li><li>python manage.py migrate 對 migration 做 migrate</li><li>python manage.py runserver 啟動 server</li><li>npm install 安裝前端套件</li><li>npm run dev 前端打包</li></ul><h3 id="加上-htmx-的-cdn-來源"><a href="#加上-htmx-的-cdn-來源" class="headerlink" title="加上 htmx 的 cdn 來源"></a>加上 htmx 的 cdn 來源</h3><p>在 HTMX 全站模板中加上 cdn 來源，讓我們可以使用 htmx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># templates/shared/base.html</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;https://unpkg.com/htmx.org@2.0.2&quot; integrity=&quot;sha384-Y7hw+L/jvKeWIRRkqWYfPcvVxHzVzn5REgzbawhxAuQGwX1XWe70vji+VSeHOThJ&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="New-Create-新增待辦"><a href="#New-Create-新增待辦" class="headerlink" title="New &#x2F; Create 新增待辦"></a>New &#x2F; Create 新增待辦</h3><p>接著我們就可以來做新增待辦</p><p>小目標：</p><ol><li>讓 New 畫面出現在 Todo List Index 頁面中，無需另外換頁</li><li>新增完成後，在 Todo List 直接出現</li></ol><p>那我們就先來做第一個小目標！</p><h4 id="讓-New-畫面出現在-Todo-List-Index-頁面中"><a href="#讓-New-畫面出現在-Todo-List-Index-頁面中" class="headerlink" title="讓 New 畫面出現在 Todo List Index 頁面中"></a>讓 New 畫面出現在 Todo List Index 頁面中</h4><p>當我們在 Todo List Index 頁面點下 <code>新增待辦</code> 時，要將 New 畫面渲染出來</p><p>所以我們就需要在 <code>新增待辦</code> 的按鈕設定 get request 的目標</p><p>htmx 支援的 http request method 及用法如下：</p><p><img src="https://imgur.com/Dldv7ZZ.jpg"></p><p>而 new 頁面是使用 GET 方式，所以我們就要在 a 標籤加上 <code>hx-get=&quot;&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># templates/items/index.html</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;/new&quot; class=&quot;m-4 btn&quot; hx-get=&quot;/new&quot;&gt;新增待辦&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>加上去之後，就可以點選看看，目前會出現在 Index 頁面，可是出現的位置不太適宜</p><p>htmx 提供了 hx-target 的 HTML 屬性，讓我們可以指定 New 畫面出現的 DOM 元素</p><p>我們在 a 標籤加上 <code>hx-target=&quot;#items&quot;</code></p><p>而該 DOM 元素的 id 就必須要是 <code>new_item</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># templates/items/index.html</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;/new&quot; class=&quot;m-4 btn&quot; hx-get=&quot;/new&quot; hx-target=&quot;#new_item&quot;&gt;新增待辦&lt;/a&gt;</span><br><span class="line">&lt;div id=&quot;new_item&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>接著就可以重整畫面，看看結果囉！</p><p><img src="https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExZ2pqYTRzMHY1NmpkM2Rzd241bDRxdzVlZ212eTVua2xkamZyZXNpdSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/ZsN8A5mBBC1v5WGoB6/giphy.gif"></p><p>接著我們要來挑戰更困難一點的！</p><h4 id="新增完成後，在-Todo-List-直接出現"><a href="#新增完成後，在-Todo-List-直接出現" class="headerlink" title="新增完成後，在 Todo List 直接出現"></a>新增完成後，在 Todo List 直接出現</h4><p>當我把待辦表單填寫完，送出後，</p><p>Todo List 的 Index 頁面就必須要出現我剛剛新增的待辦，</p><p>新增資料我們通常會使用 POST 方法，所以我們要在 form 表單加上 <code>hx-post=&quot;&quot;</code></p><p>接著可以把 action 與 method 這兩個 attribute 拿掉，</p><p>看看 htmx 發揮的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># templates/items/new.html</span><br><span class="line"></span><br><span class="line">&lt;form class=&quot;p-4&quot; hx-post=&quot;/new/&quot;&gt;</span><br><span class="line">  &#123;% csrf_token %&#125;</span><br><span class="line">  ...</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>當改完，我們填寫表單並送出後，會發現多了一組 Index 頁面內容</p><p>這是因為我們在 views 中 return 了 Index 頁面的關係</p><p>必須要改成只回傳 items 這包物件</p><p>在 views 中需要改成回傳 items 的 partial 檔案，因此回傳 HttpResponse</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># items/views.py</span><br><span class="line"></span><br><span class="line">from django.http import HttpResponseNotAllowed, HttpResponse</span><br><span class="line">from django.template.loader import render_to_string</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">def create(request):</span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        form = ItemForm(request.POST)</span><br><span class="line"></span><br><span class="line">        if form.is_valid():</span><br><span class="line">            item = Item(**form.cleaned_data)</span><br><span class="line">            item.save()</span><br><span class="line"></span><br><span class="line">            items = Item.objects.all()</span><br><span class="line">            items_partial = render_to_string(&quot;items/_items.html&quot;, &#123;&#x27;items&#x27;: items&#125;)</span><br><span class="line">            return HttpResponse(items_partial)</span><br><span class="line">    return render(request, &quot;items/new.html&quot;)</span><br><span class="line">    </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>不過這時候出現 partial 的地方也不是我們想要出現的地方，而是應該要出現在 <code>待辦事項</code> 中，因此我們需要設定 <code>hx-target=&quot;#items&quot;</code> (在 partial 檔案中的 id 為 items )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form class=&quot;p-4&quot; hx-post=&quot;/new/&quot; hx-target=&quot;#items&quot;&gt;</span><br><span class="line">  &#123;% csrf_token %&#125;</span><br><span class="line">  ...</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這時候我們點下去，會抓到 id 為 items 的 DOM 元素，並且把整包 partial 塞進去，不過這樣畫面就跑版了</p><p>這時候我們可以透過 htmx 的 Swapping 功能，指定他塞入的方式，我們要更新該 DOM 元素的內容，所以就用 <code>outerHTML</code></p><p><img src="https://imgur.com/31apXX4.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form class=&quot;p-4&quot; hx-post=&quot;/new/&quot; hx-target=&quot;#items&quot; hx-swap=&quot;outerHTML&quot;&gt;</span><br><span class="line">  &#123;% csrf_token %&#125;</span><br><span class="line">  ...</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>這樣樣式就不會跑版了</p><p>重新整理再試一次，應該就可以囉</p><p><img src="https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExaWwyeWFxOG50bWRqOG04cnlocjk2cXR2aGxpYW1udWY4aDNxcWJteSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/b8rzeyB4vfyDSGC10d/giphy.gif"></p><p>再來我們要來處理 Edit &#x2F; Update 囉</p><h3 id="Edit-Update-更新待辦"><a href="#Edit-Update-更新待辦" class="headerlink" title="Edit &#x2F; Update 更新待辦"></a>Edit &#x2F; Update 更新待辦</h3><p>小目標：</p><ol><li>讓 Edit 畫面出現在 Todo List Index 頁面中，無需另外換頁</li><li>更新完成後，在 Todo List 更新</li></ol><p>基本上應用跟 New &#x2F; Create 差不多</p><p>所以我們就直接開始！</p><h4 id="讓-Edit-畫面出現在-Todo-List-Index-頁面中"><a href="#讓-Edit-畫面出現在-Todo-List-Index-頁面中" class="headerlink" title="讓 Edit 畫面出現在 Todo List Index 頁面中"></a>讓 Edit 畫面出現在 Todo List Index 頁面中</h4><p>在編輯的按鈕給予 <code>hx-get</code> 與 <code>hx-target</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># templates/items/_items.html</span><br><span class="line"></span><br><span class="line">&#123;% load custom_filters %&#125;</span><br><span class="line"></span><br><span class="line">&lt;tbody id=&quot;items&quot;&gt;</span><br><span class="line">  &#123;% for item in items %&#125;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      ...</span><br><span class="line">      &lt;th&gt;&lt;a href=&quot;&#123;% url &#x27;items:update&#x27; item.id %&#125;&quot; class=&quot;btn&quot; hx-get=&quot;/edit/&#123;&#123; item.id &#125;&#125;&quot; hx-target=&quot;#edit_item&quot;&gt;編輯&lt;/a&gt;&lt;/th&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">&lt;/tbody&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># template/items/index.html</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&lt;div id=&quot;new_item&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;edit_item&quot;&gt;&lt;/div&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExd3hoc3Q4aTF5enFkczRwcGM1eWtrZGhzeTdpNmE1aWhrcHFrZHR4biZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/dAAE5IhTJuecTLLhIS/giphy.gif"></p><h4 id="更新完成後，在-Todo-List-更新"><a href="#更新完成後，在-Todo-List-更新" class="headerlink" title="更新完成後，在 Todo List 更新"></a>更新完成後，在 Todo List 更新</h4><p>當我把表單編輯完成，送出後，</p><p>Todo List 的 Index 頁面就必須要更新剛剛的待辦，</p><p>更新資料我們會使用 POST 方法，所以我們要在 form 表單加上 <code>hx-post=&quot;&quot;</code></p><p>接著可以把 action 與 method 這兩個 attribute 拿掉，</p><p>看看 htmx 發揮的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># templates/items/edit.html</span><br><span class="line"></span><br><span class="line">&lt;form class=&quot;p-4&quot; hx-post=&quot;/edit/&#123;&#123; item.id &#125;&#125;&quot;&gt;</span><br><span class="line">  &#123;% csrf_token %&#125;</span><br><span class="line">  ...</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>一樣到 views 中改成回傳 items 的 partial 檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># items/views.py</span><br><span class="line"></span><br><span class="line">from django.http import HttpResponseNotAllowed, HttpResponse</span><br><span class="line">from django.template.loader import render_to_string</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">def update(request, id):</span><br><span class="line">    item = get_object_or_404(Item, id=id)</span><br><span class="line"></span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        form = ItemForm(request.POST)</span><br><span class="line"></span><br><span class="line">        if form.is_valid():</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            items = Item.objects.all()</span><br><span class="line">            items_partial = render_to_string(&quot;items/_items.html&quot;, &#123;&#x27;items&#x27;: items&#125;)</span><br><span class="line">            return HttpResponse(items_partial)</span><br><span class="line">    else:</span><br><span class="line">        form = ItemForm(item.__dict__)</span><br><span class="line"></span><br><span class="line">    return render(request, &quot;items/edit.html&quot;, &#123;&quot;form&quot;: form, &quot;item&quot;: item&#125;)</span><br><span class="line">    </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>為了讓它顯示在符合預期的地方，再設定 <code>hx-target=&quot;#items&quot;</code> (在 partial 檔案中的 id 為 items )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># templates/items/edit.html</span><br><span class="line"></span><br><span class="line">&lt;form class=&quot;p-4&quot; hx-post=&quot;/edit/&#123;&#123; item.id &#125;&#125;&quot; hx-target=&quot;#items&quot;&gt;</span><br><span class="line">  &#123;% csrf_token %&#125;</span><br><span class="line">  ...</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再加上 <code>hx-swap=&quot;outerHTML&quot;</code> 讓他換掉 DOM 元素中的內容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># templates/items/edit.html</span><br><span class="line"></span><br><span class="line">&lt;form class=&quot;p-4&quot; hx-post=&quot;/edit/&#123;&#123; item.id &#125;&#125;&quot; hx-target=&quot;#items&quot; hx-swap=&quot;outerHTML&quot;&gt;</span><br><span class="line">  &#123;% csrf_token %&#125;</span><br><span class="line">  ...</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>重新整理再試一次，應該就可以囉</p><p><img src="https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExMzN2YjRheWhsZjliNHIwZHY3eHUzeG50ZzNnbnQ1dmdmbTZ2YjlqaSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/RLYFZQ2SwlUzdOrmKs/giphy.gif"></p><h3 id="當新增及編輯完成後，要讓框框消失"><a href="#當新增及編輯完成後，要讓框框消失" class="headerlink" title="當新增及編輯完成後，要讓框框消失"></a>當新增及編輯完成後，要讓框框消失</h3><p>當完成任務後，表單就可以先隱藏起來了</p><p>這邊我們會需要用到 Alpine.js </p><p>所以就先加上 Alpine.js 的 cdn 來源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># templates/shared/base.html</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><h4 id="設定框框的初始值"><a href="#設定框框的初始值" class="headerlink" title="設定框框的初始值"></a>設定框框的初始值</h4><p><code>x-data</code> 是 Alpine.js 的初始值，可以在這個屬性設定任變數與值，就可透過判斷該變數的值來完成互動效果</p><p>這邊我們會使用到 <code>x-data</code> 與 <code>x-show</code> 的屬性</p><p><code>x-show</code> 是 Alpine.js 用來判斷該 DOM 元素是否顯示</p><p>我們先將框框最外層包上一個 div 標籤</p><p>並且透過 <code>x-data</code> 設定一個變數為 open ，值為 true ，表示他們一開始都是顯示的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># templates/items/new.html</span><br><span class="line"></span><br><span class="line">&lt;div x-data=&quot;&#123; open: true &#125;&quot;&gt;</span><br><span class="line">  &lt;h1 class=&quot;p-4 mb-5 text-3xl font-bold&quot;&gt;新增待辦&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>接著要設定 <code>x-show</code> 為 <code>open</code> ，表示會判斷 open 的值來決定是否顯示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># templates/items/new.html</span><br><span class="line"></span><br><span class="line">&lt;div x-data=&quot;&#123; open: true &#125;&quot; x-show=&quot;open&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>接著，當 form 表單被送出後， open 的值要變成 false，也就是不顯示</p><p>我們就要在 form 表單上做 trigger 事件，</p><p>事件為 submit，</p><p>因此我們可以這樣用 <code>@submit=&quot;open = ! open&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># templates/items/new.html</span><br><span class="line"></span><br><span class="line">&lt;div x-data=&quot;&#123; open: true &#125;&quot; x-show=&quot;open&quot;&gt;</span><br><span class="line">  &lt;h1 class=&quot;p-4 mb-5 text-3xl font-bold&quot;&gt;新增待辦&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">  &lt;form class=&quot;p-4&quot; hx-post=&quot;/new/&quot; hx-target=&quot;#items&quot; hx-swap=&quot;outerHTML&quot; @submit=&quot;open = ! open&quot;&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>這樣新增完成後，框框就會消失囉</p><p><img src="https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExNGJqZ2I2bmF4M3pmbGw3NTNmZ3JuaTdmNGRqYjhlanZ4NWRlaGNvayZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/urKGhAhxjGctr9KFgI/giphy.gif"></p><p>接著編輯框框也是一樣的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># templates/items/edit.html</span><br><span class="line"></span><br><span class="line">&lt;div x-data=&quot;&#123; open: true &#125;&quot; x-show=&quot;open&quot;&gt;</span><br><span class="line">  &lt;h1 class=&quot;p-4 mb-5 text-3xl font-bold&quot;&gt;編輯待辦&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">  &lt;form class=&quot;p-4&quot; hx-post=&quot;/edit/&#123;&#123; item.id &#125;&#125;&quot; hx-target=&quot;#items&quot; hx-swap=&quot;outerHTML&quot; @submit=&quot;open = ! open&quot;&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>由於有些待辦會更新成已完成，我們也可以透過 Alpine.js 的 <code>x-bind</code> 來依照該屬性渲染前面的勾勾</p><p>這邊我們的 <code>x-data</code> 會設定一個變數叫做 <code>completed</code> 去判斷該 item 的 status 是否完成</p><p>我們要把該變數 bind 到 class ，判斷是否完成，已完成就會是綠色的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># templates/items/_items.html</span><br><span class="line"></span><br><span class="line">&lt;tbody id=&quot;items&quot;&gt;</span><br><span class="line">  &#123;% for item in items %&#125;</span><br><span class="line">    &lt;tr x-data=&quot;&#123; completed: &#123;&#123; item.status|is_completed &#125;&#125; &#125;&quot;&gt;</span><br><span class="line">      &lt;th :class=&quot;completed ? &#x27;text-xl cursor-pointer text-green-600&#x27; : </span><br><span class="line">      &#x27;text-xl cursor-pointer&#x27;&quot;&gt;☑&lt;/th&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">&lt;/tbody&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExcmRxcWJ1c28xbm81d2N2YmFwN2Jrbnhpc21xYXBmbTR3Z2I2MHdociZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/aknBKAquwJduDvCzz6/giphy.gif"></p><p>以上，是 htmx 與 Alpine.js 的簡單應用介紹，</p><p>htmx 與 Alpine.js 並不是用來取代前端框架的，</p><p>他的目的是要讓後端工程師用更輕便且不需要打包的方式來完成前端效果，</p><p>增加網頁開發效率，也減少後端工程師的前端框架學習成本，</p><p>如果有興趣的話也可以至 <a href="https://htmx.org/docs/#introduction">htmx</a> 與 <a href="https://alpinejs.dev/">Alpine.js</a> 官網研究，</p><p>如果本文章對你有幫助，歡迎按讚或者留言討論 ヽ(●´∀&#96;●)ﾉ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;身為後端工程師，在處理前端的時候，&lt;/p&gt;
&lt;p&gt;不是要去學框架就是要用純 JavaScript ，&lt;/p&gt;
&lt;p&gt;在 Ruby on Rails 有 Hotwire 與 Stimulus.js，&lt;/p&gt;
&lt;p&gt;可以輕鬆達到即時渲染及前端互動的效果，&lt;/p&gt;
&lt;p&gt;不過在其</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://ninglab.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>成為程式界的 F1 賽車手 - Rust 標準函式庫型別</title>
    <link href="http://ninglab.com/%E6%88%90%E7%82%BA%E7%A8%8B%E5%BC%8F%E7%95%8C%E7%9A%84-F1-%E8%B3%BD%E8%BB%8A%E6%89%8B-Rust-%E6%A8%99%E6%BA%96%E5%87%BD%E5%BC%8F%E5%BA%AB%E5%9E%8B%E5%88%A5/"/>
    <id>http://ninglab.com/%E6%88%90%E7%82%BA%E7%A8%8B%E5%BC%8F%E7%95%8C%E7%9A%84-F1-%E8%B3%BD%E8%BB%8A%E6%89%8B-Rust-%E6%A8%99%E6%BA%96%E5%87%BD%E5%BC%8F%E5%BA%AB%E5%9E%8B%E5%88%A5/</id>
    <published>2024-09-08T14:58:58.000Z</published>
    <updated>2024-09-08T14:59:27.271Z</updated>
    
    <content type="html"><![CDATA[<p>我們將會從標准函式庫提供的型別開始講起，在了解型別以前，</p><p>想來提一個重要的東西，而且我們未來也會一直提到他 - Macro</p><h2 id="Macro"><a href="#Macro" class="headerlink" title="Macro"></a>Macro</h2><p>可以把 Macro 看成是一種函式，不過他提供的功能更廣泛，概念偏向 metaprogramming，在程式碼裡面編寫程式碼，減少重複的程式碼，並且在編譯時產生代碼</p><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector 是一種存放資料的集合型別，放置在同一個 vector 裡面的資料都是要一樣型態的</p><p>讓我們來看一下該怎麼做出 vector</p><p>如果是要產生空的 vector，我們可以用這個方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let collection: Vec&lt;i8&gt; = Vec::new();</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不過要記得產生空的，一定要給他內容的型態，不然就會噴錯誤唷！</p><p>如果不是要產生空的，一開始我們就知道內容要放什麼的話，可以用以下方式做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let collection = vec![1, 2, 3, 4];</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>當我們在 VS Code 中打出這段時，會自動多出了 <code>Vec&lt;i32&gt;</code></p><p>會去自動判斷裡面資料的型態</p><p>但如果裡面有個型態不一樣呢？</p><p>登愣，就會噴出型態不一樣的錯誤啦！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let collection = vec![1, 2, 3, 4, &#x27;o&#x27;];</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"> --&gt; src/main.rs:2:39</span><br><span class="line">  |</span><br><span class="line">2 |     let collection = vec![1, 2, 3, 4, &#x27;o&#x27;];</span><br><span class="line">  |                                       ^^^ expected integer, found `char`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0308`.</span><br><span class="line">error: could not compile `hello_world` (bin &quot;hello_world&quot;) due to previous error</span><br></pre></td></tr></table></figure><p>vector 裡面的元素 index 值跟 array 一樣，從 0 開始算</p><p>要存取其中一個 index 的方式也跟 array 一樣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut collection = vec![1, 2, 3, 4];</span><br><span class="line">    collection.push(5);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection[1])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>如果要在 vector 加入新元素，可以用 push() 方法<br>不過要記得在 vector 定義的時候給予 mut 讓他知道是可以更改的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut collection = vec![1, 2, 3, 4];</span><br><span class="line">    collection.push(5);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>如果要移除某個元素呢？ 使用 remove() 方法，不過要加的是 index 值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut collection = vec![1, 2, 3, 4];</span><br><span class="line">    collection.remove(0);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">[2, 3, 4]</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>我們在高階語言，字串通常都是程式語言的核心型態，不過在 Rust 中，字串是標準函示庫提供的型態唷</p><p>所以在產出 String 的時候是需要用方法去做的</p><p>今天如果要做出一個空字串，我們可以用下列這個方法做</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let my_name = String::new();</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, my_name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">&quot;&quot;</span><br></pre></td></tr></table></figure><p>如果已經知道字串要有哪些內容了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let my_name = String::from(&quot;Ning&quot;);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, my_name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">&quot;Ning&quot;</span><br></pre></td></tr></table></figure><p>假設我們今天要對字串增加內容呢？</p><p>使用 push_str 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut my_name = String::from(&quot;Ning&quot;);</span><br><span class="line">    my_name.push_str(&quot; Chang&quot;);</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, my_name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">&quot;Ning Chang&quot;</span><br></pre></td></tr></table></figure><p>如果想要取出字串某個個單字呢？</p><p>使用字串切片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut my_name = String::from(&quot;Ning&quot;);</span><br><span class="line">    my_name.push_str(&quot; Chang&quot;);</span><br><span class="line"></span><br><span class="line">    let name = &amp;my_name[0..4];</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">&quot;Ning&quot;</span><br></pre></td></tr></table></figure><p>在 Rust 中，標准函式庫提供了兩種 hash 格式，分別是 HashMap 及 HashSet </p><p>兩者差異在哪呢？</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>就像是我們在高階語言的 hash 型態，有一組組 key 跟 value</p><p>要使用需要先導入 HashMap 模組</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let collection: HashMap&lt;String, i8&gt; = HashMap::new();</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果要加入元素的話，我們可以用 <code>insert</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut collection: HashMap&lt;String, i8&gt; = HashMap::new();</span><br><span class="line"></span><br><span class="line">    collection.insert(String::from(&quot;first&quot;), 2);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">&#123;&quot;first&quot;: 2&#125;</span><br></pre></td></tr></table></figure><p>如果要拿取其中一個元素，可以用 <code>get</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut collection: HashMap&lt;i32, i8&gt; = HashMap::new();</span><br><span class="line"></span><br><span class="line">    collection.insert(1, 2);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection.get(&amp;1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">Some(2)</span><br></pre></td></tr></table></figure><p>要注意的是 get(&amp;) 只接受 i32 資料格式</p><h4 id="Some-、-Option"><a href="#Some-、-Option" class="headerlink" title="Some 、 Option"></a>Some 、 Option</h4><p>如果要移除其中一個 pair 呢? 使用 <code>remove</code> 及 i32 的值就可以囉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut collection: HashMap&lt;i32, i8&gt; = HashMap::new();</span><br><span class="line"></span><br><span class="line">    collection.insert(1, 2);</span><br><span class="line">    collection.insert(2, 3);</span><br><span class="line"></span><br><span class="line">    collection.remove(&amp;1);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">&#123;2, 3&#125;</span><br></pre></td></tr></table></figure><p>如果要更新呢？ 一樣是使用 <code>insert</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut collection: HashMap&lt;i32, i8&gt; = HashMap::new();</span><br><span class="line"></span><br><span class="line">    collection.insert(1, 2);</span><br><span class="line">    collection.insert(1, 3);</span><br><span class="line"></span><br><span class="line">    collection.insert(1, 4);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">&#123;1, 4&#125;</span><br></pre></td></tr></table></figure><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet 也是類似高階語言中的 hash 型態，不過跟 HashMap 不一樣的是，他不允許重複的 key 跟 value，而且不能更改(下 mut 也不行)</p><p>我們在建立一個 HashSet 的時候也只能指定他的 value 是什麼</p><p>來看一下該怎麼建立吧！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashSet;</span><br><span class="line"></span><br><span class="line">    let mut collection: HashSet&lt;i32&gt; = HashSet::new();</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>一開始就有預設值的話，我們可以這樣設定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashSet;</span><br><span class="line"></span><br><span class="line">    let collection: HashSet&lt;i32&gt; = HashSet::from([2, 3, 4, 5]);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要加入一個值的話，我們一樣是使用 <code>insert()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashSet;</span><br><span class="line"></span><br><span class="line">    let mut collection: HashSet&lt;i32&gt; = HashSet::new();</span><br><span class="line"></span><br><span class="line">    collection.insert(2);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">&#123;2&#125;</span><br></pre></td></tr></table></figure><p>移除一樣是使用 remove()</p><p>不過這邊參數是要帶 value，而非 key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashSet;</span><br><span class="line"></span><br><span class="line">    let mut collection: HashSet&lt;i32&gt; = HashSet::new();</span><br><span class="line"></span><br><span class="line">    collection.insert(2);</span><br><span class="line">    collection.insert(3);</span><br><span class="line">    collection.insert(4);</span><br><span class="line"></span><br><span class="line">    collection.remove(&amp;2);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下來要介紹一些 HashSet 進階用法</p><p>首先我們要來找出兩個 HashSet 中的交集，可以使用 <code>intersection()</code> 方法來做</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashSet;</span><br><span class="line"></span><br><span class="line">    let collection1: HashSet&lt;i32&gt; = HashSet::from([2, 3, 4, 5]);</span><br><span class="line">    let collection2: HashSet&lt;i32&gt; = HashSet::from([1, 2, 5]);</span><br><span class="line"></span><br><span class="line">    let collection3 = collection1.intersection(&amp;collection2);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">[2, 5]</span><br></pre></td></tr></table></figure><p>如果我們要讓他們結合兩個 HashSet ，且刪除重複值，可以使用 <code>union()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashSet;</span><br><span class="line"></span><br><span class="line">    let collection1: HashSet&lt;i32&gt; = HashSet::from([2, 3, 4, 5]);</span><br><span class="line">    let collection2: HashSet&lt;i32&gt; = HashSet::from([1, 2, 5]);</span><br><span class="line"></span><br><span class="line">    let collection3 = collection1.union(&amp;collection2);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">[3, 5, 2, 4, 1]</span><br></pre></td></tr></table></figure><p>** 解釋為什麼第一個是 3 (跟迭代有關)</p><p>如果要找出兩個之間不一樣的值呢？ 使用 <code>difference()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashSet;</span><br><span class="line"></span><br><span class="line">    let collection1: HashSet&lt;i32&gt; = HashSet::from([2, 3, 4, 5]);</span><br><span class="line">    let collection2: HashSet&lt;i32&gt; = HashSet::from([1, 2, 5]);</span><br><span class="line"></span><br><span class="line">    let collection3 = collection1.difference(&amp;collection2);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, collection3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">結果：</span><br><span class="line">[4, 3]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我們將會從標准函式庫提供的型別開始講起，在了解型別以前，&lt;/p&gt;
&lt;p&gt;想來提一個重要的東西，而且我們未來也會一直提到他 - Macro&lt;/p&gt;
&lt;h2 id=&quot;Macro&quot;&gt;&lt;a href=&quot;#Macro&quot; class=&quot;headerlink&quot; title=&quot;Macro&quot;</summary>
      
    
    
    
    <category term="Rust" scheme="http://ninglab.com/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>成為程式界的 F1 賽車手 - Rust 型別轉換</title>
    <link href="http://ninglab.com/%E6%88%90%E7%82%BA%E7%A8%8B%E5%BC%8F%E7%95%8C%E7%9A%84-F1-%E8%B3%BD%E8%BB%8A%E6%89%8B%20-%20Rust%20%E5%9E%8B%E5%88%A5%E8%BD%89%E6%8F%9B/"/>
    <id>http://ninglab.com/%E6%88%90%E7%82%BA%E7%A8%8B%E5%BC%8F%E7%95%8C%E7%9A%84-F1-%E8%B3%BD%E8%BB%8A%E6%89%8B%20-%20Rust%20%E5%9E%8B%E5%88%A5%E8%BD%89%E6%8F%9B/</id>
    <published>2024-09-07T09:17:53.000Z</published>
    <updated>2024-09-07T09:44:19.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="轉換型別"><a href="#轉換型別" class="headerlink" title="轉換型別"></a>轉換型別</h3><p>在 Rust 中該怎麼轉換型別呢？</p><p>只要加上 <code>as</code> 就可以了</p><p>讓我們來看一下吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let price: f32 = 18.5;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, price);</span><br><span class="line"></span><br><span class="line">    let modified_price = price as i8;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, modified_price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果： 18.5</span><br><span class="line"># 結果： 18</span><br></pre></td></tr></table></figure><p>不過如果今天要把整數轉成字呢？</p><p>他會依照 Unicode 編碼來進行轉換，不過要注意的是，只有 <code>u8</code> 能轉換成 <code>char</code> 哦，因為 Unicode 的編碼並不多，所以只適用在 <code>u8</code> 範圍</p><p>而這個數字在 Unicode 編碼沒有對應的字，就會顯示空的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let num: u8 = 33;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, num);</span><br><span class="line"></span><br><span class="line">    let character = num as char;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, character);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果： 33</span><br><span class="line"># 結果： !</span><br></pre></td></tr></table></figure><p>雖然 Rust 可以用 <code>as</code> 方式去轉換型別，不過也不是所有的型別都可以轉換過去哦</p><p>就像我們剛剛要轉換成 <code>char</code> 時，只有 <code>u8</code> 能夠轉</p><h3 id="運算式"><a href="#運算式" class="headerlink" title="運算式"></a>運算式</h3><p>在介紹基本型別後，我們要開始進入邏輯階段了！</p><p>首先要來認識一下運算子</p><p>在 Rust 中有幾個運算式</p><ul><li>算術運算式</li><li>複合指定運算式</li><li>邏輯運算式</li><li>比較運算式</li></ul><p>我們直接一個一個來介紹</p><h4 id="算術運算式"><a href="#算術運算式" class="headerlink" title="算術運算式"></a>算術運算式</h4><p>顧名思義就是加減乘除，還有多一個餘數</p><h5 id="要用加法的話，使用"><a href="#要用加法的話，使用" class="headerlink" title="要用加法的話，使用 +"></a>要用加法的話，使用 <code>+</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let num1: i8 = 33;</span><br><span class="line">    let num2: i8 = 20;</span><br><span class="line">    let total = num1 + num2;</span><br><span class="line"></span><br><span class="line">    println!(&quot;num1 + num2 = &#123;&#125;&quot;, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果：num1 + num2 = 53</span><br></pre></td></tr></table></figure><h5 id="減法使用"><a href="#減法使用" class="headerlink" title="減法使用 -"></a>減法使用 <code>-</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let num1: i8 = 33;</span><br><span class="line">    let num2: i8 = 20;</span><br><span class="line">    let total = num1 - num2;</span><br><span class="line"></span><br><span class="line">    println!(&quot;num1 - num2 = &#123;&#125;&quot;, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果：num1 + num2 = 13</span><br></pre></td></tr></table></figure><h5 id="乘法使用"><a href="#乘法使用" class="headerlink" title="乘法使用 *"></a>乘法使用 <code>*</code></h5><p>這邊我把型別都改成了 <code>i32</code>，因為 <code>i8</code> 無法支援相乘後的結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let num1: i32 = 33;</span><br><span class="line">    let num2: i32 = 20;</span><br><span class="line"></span><br><span class="line">    let total = num1 * num2;</span><br><span class="line"></span><br><span class="line">    println!(&quot;num1 * num2 = &#123;&#125;&quot;, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果：num1 * num2 = 660</span><br></pre></td></tr></table></figure><h5 id="除法使用"><a href="#除法使用" class="headerlink" title="除法使用 /"></a>除法使用 <code>/</code></h5><p>這邊要注意，整數相除的結果會是整數，浮點數相除的結果會是浮點數</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let num1: i8 = 33;</span><br><span class="line">    let num2: i8 = 20;</span><br><span class="line"></span><br><span class="line">    let total = num1 / num2;</span><br><span class="line"></span><br><span class="line">    println!(&quot;num1 / num2 = &#123;&#125;&quot;, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果：num1 / num2 = 1</span><br></pre></td></tr></table></figure><h5 id="取餘數使用"><a href="#取餘數使用" class="headerlink" title="取餘數使用 %"></a>取餘數使用 <code>%</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let num1: i8 = 33;</span><br><span class="line">    let num2: i8 = 20;</span><br><span class="line"></span><br><span class="line">    let total = num1 % num2;</span><br><span class="line"></span><br><span class="line">    println!(&quot;num1 % num2 = &#123;&#125;&quot;, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果：num1 % num2 = 13</span><br></pre></td></tr></table></figure><p>以上是基本的加減乘除，相信大家到這邊應該都可以輕易理解，接下來我們就進入 <code>複合指定運算式</code></p><h3 id="複合指定運算式"><a href="#複合指定運算式" class="headerlink" title="複合指定運算式"></a>複合指定運算式</h3><p>在前幾天有提到，要定義變數使用 <code>=</code> 去變動，這是所謂的指定運算子</p><p>那 <code>複合指定運算式</code> 是什麼？</p><p>當我們想針對原本的數值做加減乘除，就可以使用 複合指定運算式</p><p>我們直接用舉例會比較清楚</p><p>以加法來說，假設今天有個變數 a 的值是 2 ，我希望改變他的值，讓他 +1 後變成 3，我們就可以用 <code>+=</code> 來達成</p><p>在看範例之前，我們來了解 <code>+=</code> 是怎麼解讀</p><p><code>num += 2</code> 可以解讀成 <code>num = num + 2</code></p><p>減乘除、求餘數同理，在運作子後面加上 <code>=</code> 即可成立囉</p><p>減乘除、求餘數會分別是(<code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code>) </p><p>(記得要加上 mut ，不然會噴錯喔！)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut num1: i8 = 33;</span><br><span class="line"></span><br><span class="line">    num1 += 2;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, num1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果：35</span><br></pre></td></tr></table></figure><h3 id="比較運算式"><a href="#比較運算式" class="headerlink" title="比較運算式"></a>比較運算式</h3><p>基本上就是 <code>&gt;</code> <code>&lt;</code> <code>=</code> 這類的比較</p><p>結果會返回一個布林值，讓我們直接來看範例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let greater = 5 &gt; 3;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, greater);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果：true</span><br></pre></td></tr></table></figure><p>會有哪些比較運算式呢？</p><p><code>&gt;</code> 左邊大於右邊 成立的時候返回 <code>true</code> ，反之 <code>false</code><br><code>&gt;=</code> 左邊大於或等於右邊 成立的時候返回 <code>true</code>，反之 <code>false</code><br><code>&lt;</code> 左邊小於右邊 成立的時候返回 <code>true</code> ，反之 <code>false</code><br><code>&lt;=</code> 左邊小於或等於右邊 成立的時候返回 <code>true</code> ，反之 <code>false</code><br><code>==</code> 左邊等於右邊 成立的時候返回 <code>true</code> ，反之 <code>false</code><br><code>!=</code> 左邊不等於右邊 成立的時候返回 <code>true</code> ，反之 <code>false</code></p><h3 id="邏輯運算式"><a href="#邏輯運算式" class="headerlink" title="邏輯運算式"></a>邏輯運算式</h3><p>這邊可能就要稍微動動理解力！</p><p>會有三個邏輯運算式，我們以下詳細講解：</p><h5 id=""><a href="#" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h5><p><code>&amp;&amp;</code> 當兩邊的條件式都成立時(結果都是 true ) 即返回 true，反之 <code>false</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let greater = 5 &gt; 3;</span><br><span class="line">    let less = 6 &gt; 4;</span><br><span class="line"></span><br><span class="line">    # greater 跟 less 都是 true，因此 operate 也會是 true</span><br><span class="line">    let operation = greater &amp;&amp; less;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, operation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果： true</span><br></pre></td></tr></table></figure><p>來稍微動個手腳，把 less 結果變成 <code>false</code></p><p>這時候 operation 就會變成 <code>false</code></p><p>因為 <code>&amp;&amp;</code> 是在兩個條件式都是 <code>true</code> 的情況下才會是 <code>true</code></p><p>其中一個不是 <code>true</code> 或者是 第一個就是 <code>false</code> ，就會直接返回 <code>false</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let greater = 5 &gt; 3;</span><br><span class="line">    let less = 6 &lt; 4;</span><br><span class="line"></span><br><span class="line">    let operation = greater &amp;&amp; less;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, operation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果： false</span><br></pre></td></tr></table></figure><h5 id="-1"><a href="#-1" class="headerlink" title="||"></a>||</h5><p><code>||</code> 當其中一邊的條件式成立時(某一邊結果是 true) 即返回 true，反之 <code>false</code></p><p>拿剛剛的例子來做範例，我們改一下運算子為 <code>||</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let greater = 5 &gt; 3;</span><br><span class="line">    let less = 6 &lt; 4;</span><br><span class="line"></span><br><span class="line">    # greater 為 true ， less 為 false，以 || 來看只要有個 true，就無條件返回 true</span><br><span class="line">    let operation = greater || less;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, operation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果： true</span><br></pre></td></tr></table></figure><p>如果兩個結果都是 false 呢？ 就會返回 false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let greater = 5 &lt; 3;</span><br><span class="line">    let less = 6 &lt; 4;</span><br><span class="line"></span><br><span class="line">    # greater 為 true ， less 為 false，以 || 來看只要有個 true，就無條件返回 true</span><br><span class="line">    let operation = greater || less;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, operation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果： false</span><br></pre></td></tr></table></figure><h5 id="-2"><a href="#-2" class="headerlink" title="!"></a>!</h5><p><code>!</code> 代表相反的意思</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let less = 6 &lt; 4;</span><br><span class="line"></span><br><span class="line">    # 原本的 less 為 false，加了 ! 後反轉，因此 operation 就成了 true</span><br><span class="line">    let operation = !less;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, operation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果： ture</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;轉換型別&quot;&gt;&lt;a href=&quot;#轉換型別&quot; class=&quot;headerlink&quot; title=&quot;轉換型別&quot;&gt;&lt;/a&gt;轉換型別&lt;/h3&gt;&lt;p&gt;在 Rust 中該怎麼轉換型別呢？&lt;/p&gt;
&lt;p&gt;只要加上 &lt;code&gt;as&lt;/code&gt; 就可以了&lt;/p&gt;
&lt;p&gt;讓我們來</summary>
      
    
    
    
    <category term="Rust" scheme="http://ninglab.com/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>成為程式界的 F1 賽車手 - Rust 與變數們</title>
    <link href="http://ninglab.com/%E6%88%90%E7%82%BA%E7%A8%8B%E5%BC%8F%E7%95%8C%E7%9A%84%20F1%20%E8%B3%BD%E8%BB%8A%E6%89%8B%20-%20Rust%20%E8%88%87%E8%AE%8A%E6%95%B8%E5%80%91/"/>
    <id>http://ninglab.com/%E6%88%90%E7%82%BA%E7%A8%8B%E5%BC%8F%E7%95%8C%E7%9A%84%20F1%20%E8%B3%BD%E8%BB%8A%E6%89%8B%20-%20Rust%20%E8%88%87%E8%AE%8A%E6%95%B8%E5%80%91/</id>
    <published>2024-09-05T16:13:47.000Z</published>
    <updated>2024-09-05T17:05:13.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="淺談-Rust-淵源"><a href="#淺談-Rust-淵源" class="headerlink" title="淺談 Rust 淵源"></a>淺談 Rust 淵源</h3><p>Rust 是由 Mozilla 主導開發</p><p>Rust 本來是 Mozilla 員工 Graydon Hoare 的 side project</p><p>後來 Mozilla 開始支持這個專案，在 2010 年公開</p><p>並於 2015 年釋出第一個穩定版本</p><p>截至 2024 年 8 月已釋出 1.80.1 穩定版</p><p>Rust 在 stack overflow 的 2024 年調查中，Rust 被列為最讚賞的語言之一</p><p>Rust 的高效能特性，讓許多的工具都掀起以 Rust 的改寫風潮</p><h3 id="該怎麼安裝"><a href="#該怎麼安裝" class="headerlink" title="該怎麼安裝"></a>該怎麼安裝</h3><p>本系列文章將以 MacOS 為主</p><p>官方推薦使用 rustup 來安裝， Window 需要另行安裝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">info: downloading installer</span><br><span class="line"></span><br><span class="line">Welcome to Rust!</span><br><span class="line"></span><br><span class="line">This will download and install the official compiler for the Rust</span><br><span class="line">programming language, and its package manager, Cargo.</span><br><span class="line"></span><br><span class="line">Rustup metadata and toolchains will be installed into the Rustup</span><br><span class="line">home directory, located at:</span><br><span class="line"></span><br><span class="line">  /Users/zhangjianing/.rustup</span><br><span class="line"></span><br><span class="line">This can be modified with the RUSTUP_HOME environment variable.</span><br><span class="line"></span><br><span class="line">The Cargo home directory is located at:</span><br><span class="line"></span><br><span class="line">  /Users/zhangjianing/.cargo</span><br><span class="line"></span><br><span class="line">This can be modified with the CARGO_HOME environment variable.</span><br><span class="line"></span><br><span class="line">The cargo, rustc, rustup and other commands will be added to</span><br><span class="line">Cargo&#x27;s bin directory, located at:</span><br><span class="line"></span><br><span class="line">  /Users/zhangjianing/.cargo/bin</span><br><span class="line"></span><br><span class="line">This path will then be added to your PATH environment variable by</span><br><span class="line">modifying the profile files located at:</span><br><span class="line"></span><br><span class="line">  /Users/zhangjianing/.profile</span><br><span class="line">  /Users/zhangjianing/.bash_profile</span><br><span class="line">  /Users/zhangjianing/.bashrc</span><br><span class="line">  /Users/zhangjianing/.zshenv</span><br><span class="line"></span><br><span class="line">You can uninstall at any time with rustup self uninstall and</span><br><span class="line">these changes will be reverted.</span><br><span class="line"></span><br><span class="line">Current installation options:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   default host triple: aarch64-apple-darwin</span><br><span class="line">     default toolchain: stable (default)</span><br><span class="line">               profile: default</span><br><span class="line">  modify PATH variable: yes</span><br><span class="line"></span><br><span class="line">1) Proceed with installation (default)</span><br><span class="line">2) Customize installation</span><br><span class="line">3) Cancel installation</span><br></pre></td></tr></table></figure><p>沒有特別要設定就選 1 吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&gt;1</span><br><span class="line"></span><br><span class="line">info: profile set to &#x27;default&#x27;</span><br><span class="line">info: default host triple is aarch64-apple-darwin</span><br><span class="line">info: syncing channel updates for &#x27;stable-aarch64-apple-darwin&#x27;</span><br><span class="line">781.5 KiB / 781.5 KiB (100 %) 699.0 KiB/s in  1s ETA:  0s</span><br><span class="line">info: latest update on 2023-08-03, rust version 1.71.1 (eb26296b5 2023-08-03)</span><br><span class="line">info: downloading component &#x27;cargo&#x27;</span><br><span class="line">  5.0 MiB /   5.0 MiB (100 %)   1.1 MiB/s in  4s ETA:  0s</span><br><span class="line">info: downloading component &#x27;clippy&#x27;</span><br><span class="line">  1.9 MiB /   1.9 MiB (100 %)   1.1 MiB/s in  1s ETA:  0s</span><br><span class="line">info: downloading component &#x27;rust-docs&#x27;</span><br><span class="line"> 13.6 MiB /  13.6 MiB (100 %)   1.6 MiB/s in 10s ETA:  0s</span><br><span class="line">info: downloading component &#x27;rust-std&#x27;</span><br><span class="line"> 23.7 MiB /  23.7 MiB (100 %)   1.9 MiB/s in 14s ETA:  0s</span><br><span class="line">info: downloading component &#x27;rustc&#x27;</span><br><span class="line"> 52.6 MiB /  52.6 MiB (100 %)   3.3 MiB/s in 27s ETA:  0s</span><br><span class="line">info: downloading component &#x27;rustfmt&#x27;</span><br><span class="line">  1.4 MiB /   1.4 MiB (100 %)   1.0 MiB/s in  2s ETA:  0s</span><br><span class="line">info: installing component &#x27;cargo&#x27;</span><br><span class="line">info: installing component &#x27;clippy&#x27;</span><br><span class="line">info: installing component &#x27;rust-docs&#x27;</span><br><span class="line"> 13.6 MiB /  13.6 MiB (100 %)   7.2 MiB/s in  1s ETA:  0s</span><br><span class="line">info: installing component &#x27;rust-std&#x27;</span><br><span class="line"> 23.7 MiB /  23.7 MiB (100 %)  19.2 MiB/s in  1s ETA:  0s</span><br><span class="line">info: installing component &#x27;rustc&#x27;</span><br><span class="line"> 52.6 MiB /  52.6 MiB (100 %)  21.6 MiB/s in  2s ETA:  0s</span><br><span class="line">info: installing component &#x27;rustfmt&#x27;</span><br><span class="line">info: default toolchain set to &#x27;stable-aarch64-apple-darwin&#x27;</span><br><span class="line"></span><br><span class="line">  stable-aarch64-apple-darwin installed - rustc 1.71.1 (eb26296b5 2023-08-03)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Rust is installed now. Great!</span><br><span class="line"></span><br><span class="line">To get started you may need to restart your current shell.</span><br><span class="line">This would reload your PATH environment variable to include</span><br><span class="line">Cargo&#x27;s bin directory ($HOME/.cargo/bin).</span><br><span class="line"></span><br><span class="line">To configure your current shell, run:</span><br><span class="line">source &quot;$HOME/.cargo/env&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安裝完畢就可以確認安裝的版本（記得要重開終端機）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; rustc --version</span><br><span class="line"></span><br><span class="line"># rustc 1.80.1 (3f5fd8dd4 2024-08-06)</span><br></pre></td></tr></table></figure><h3 id="印出-Hello-World"><a href="#印出-Hello-World" class="headerlink" title="印出 Hello World"></a>印出 Hello World</h3><p>我們先來做一個 rs 檔案 ( Rust 的原始碼檔案) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch hello.rs</span><br></pre></td></tr></table></figure><p>打開 hello.rs 檔案，輸入下列這段程式碼後存檔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust 是編譯語言，在進入執行其之前需要先編譯成電腦看得懂的語言，<br>所以我們用 rustc 來編譯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc hello.rs</span><br></pre></td></tr></table></figure><p>接著執行這個檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello.rs</span><br></pre></td></tr></table></figure><p>就會出現 <code>Hello, World!</code> 囉</p><h3 id="註解"><a href="#註解" class="headerlink" title="註解"></a>註解</h3><p>為了防止程式語言寫得過於艱深，或者是比較特殊的功能<br>我們會用註解 (comments) 來解釋程式碼</p><p>在 Rust 中，該怎麼下註解呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 這是單行註解</span><br><span class="line">/*...*/ 這是多行註解</span><br></pre></td></tr></table></figure><p>以剛剛的 hello.rs 來示範單行註解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // first, say hello to the world.</span><br><span class="line">    println!(&quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那多行註解呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    /* </span><br><span class="line">    I&#x27;m beginner of rust,</span><br><span class="line">    but I&#x27;ll work hard!</span><br><span class="line">    */</span><br><span class="line">    println!(&quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寫好再重新編譯，結果依然是印出 Hello, World! 唷</p><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p>在 Rust 中，要印出東西，可以用兩種 Macro，<br>分別是 print! 跟 println!</p><ul><li>什麼是 Macro?</li></ul><p>Macro 有點像 Function ，但其實不能跟 Function 劃上等號，Macro 的概念更像是 Meta Programming，就是以程式來撰寫程式的意思</p><p>我們直接在 hello.rs 中試試</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  print!(&quot;Hello,&quot;);</span><br><span class="line">  print!(&quot;World!&quot;);</span><br><span class="line">  </span><br><span class="line">  println!(&quot;Hello,&quot;);</span><br><span class="line">  println!(&quot;World!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一樣編譯後再執行，這時候終端機的結果是這樣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello,World!Hello,</span><br><span class="line">World!</span><br></pre></td></tr></table></figure><p>由上述結果可知道 <code>print!</code> 不會換行<br><code>ln</code> 會在後面加上換行的動作<br>所以 <code>println!</code> 會換行</p><p>不過這個只能印字串，如果要印變數，必須這樣使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = &quot;Hello&quot;;</span><br><span class="line">println!(&quot;&#123;&#125;&quot;, a);</span><br></pre></td></tr></table></figure><p>cannot be formatted with the default formatter<br>有時候會跑出該型態不支援預設 formatter 的錯誤，這時我們就必須這樣用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = [1, 2, 3];</span><br><span class="line">println!(&quot;&#123;:?&#125;&quot;, a);</span><br></pre></td></tr></table></figure><h3 id="變數"><a href="#變數" class="headerlink" title="變數"></a>變數</h3><p>當我們需要將一個值儲存起來，在日後做使用的時候，我們就需要用到變數</p><p>將變數指向這個值，需要的時候再拿出來用他</p><p>我們來看一下在 Rust 中該怎麼定義變數</p><h4 id="定義變數"><a href="#定義變數" class="headerlink" title="定義變數"></a>定義變數</h4><p>我們會用 <code>let</code> 來定義變數 (有點像 JavaScript)，來看看以下範例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let aa = 1;</span><br></pre></td></tr></table></figure><p>我們會定義出一個 aa 的變數，並將它的值指向 1</p><p>接下來我們試著印出變數</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let age = 18;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rustc main.rs</span><br><span class="line">$ ./main</span><br><span class="line"></span><br><span class="line"># 18</span><br></pre></td></tr></table></figure><p>Rust 對於變數相對嚴謹，基本上定義後就不能再改變</p><p>如果有天突然想給他改值呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let age = 18;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ rustc main.rs</span><br><span class="line"></span><br><span class="line">error[E0384]: cannot assign twice to immutable variable `age`</span><br><span class="line"> --&gt; main.rs:5:3</span><br><span class="line">  |</span><br><span class="line">2 |   let age = 18;</span><br><span class="line">  |       ---</span><br><span class="line">  |       |</span><br><span class="line">  |       first assignment to `age`</span><br><span class="line">  |       help: consider making this binding mutable: `mut age`</span><br><span class="line">...</span><br><span class="line">5 |   age = 19;</span><br><span class="line">  |   ^^^^^^^^ cannot assign twice to immutable variable</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0384`.</span><br></pre></td></tr></table></figure><p>在編譯的時候就直接噴錯</p><p>但我們一定會需要改變變數值的時候，該怎麼做呢？</p><p>使用 <code>mut</code> 就可以定義一個可變的變數</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let mut age = 18;</span><br></pre></td></tr></table></figure><p>我們實際來試試</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let mut age = 18;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, age);</span><br><span class="line"></span><br><span class="line">  age = 19;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rustc main.rs</span><br><span class="line">$ ./main</span><br><span class="line"></span><br><span class="line"># 18</span><br><span class="line"># 19</span><br></pre></td></tr></table></figure><p>以上是 Rust 定義變數的方式</p><h4 id="變數命名規則"><a href="#變數命名規則" class="headerlink" title="變數命名規則"></a>變數命名規則</h4><p>在 Rust 中，大寫與小寫是不同的，所以 age !&#x3D; AGE</p><p>還有幾個規則務必要遵守</p><ul><li>開頭不可用數字</li><li>除了英文 &#x2F; 數字 &#x2F; 底線以外，不可加入其他符號或語言文字</li><li>如果會有兩個以上的單字，請用蛇式命名法，比如說變數名稱是我的年齡，可取作 my_age</li></ul><h3 id="常數是什麼"><a href="#常數是什麼" class="headerlink" title="常數是什麼"></a>常數是什麼</h3><p>常數顧名思義就是永恆不變的，所以基本上他是不能被改變的</p><h3 id="定義常數"><a href="#定義常數" class="headerlink" title="定義常數"></a>定義常數</h3><p>在 Rust 中定義常數的方式跟 JavaScript 很像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const PI: f32 = 3.14;</span><br></pre></td></tr></table></figure><ul><li>定義方式：使用 const</li><li>名稱：const 後面必須接大寫</li><li>指定型別：需指定型別給它，否則他會自行判斷，稍後我們會介紹型別</li></ul><p>之後再賦予一個值給常數即可</p><p>我們來試試印出常數</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  const AGE: i8 = 18;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, AGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rustc main.rs</span><br><span class="line">$ ./main</span><br><span class="line"></span><br><span class="line"># 18</span><br></pre></td></tr></table></figure><p>如果我們想改常數的值呢？會發生什麼事</p><p>應該想都不用想就是會噴錯，不過會噴什麼錯誤呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  const AGE: i8 = 18;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, AGE);</span><br><span class="line"></span><br><span class="line">  AGE = 19;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, AGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ rustc main.rs</span><br><span class="line"></span><br><span class="line">error[E0070]: invalid left-hand side of assignment</span><br><span class="line"> --&gt; main.rs:5:7</span><br><span class="line">  |</span><br><span class="line">5 |   AGE = 19;</span><br><span class="line">  |   --- ^</span><br><span class="line">  |   |</span><br><span class="line">  |   cannot assign to this expression</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0070`.</span><br></pre></td></tr></table></figure><p>它會跟你說左邊的定義是不合法的唷！</p><h3 id="基本型別"><a href="#基本型別" class="headerlink" title="基本型別"></a>基本型別</h3><p>Rust 屬於強型別語言，必須明確定義型別給它，否則他會自行判斷型別</p><p>我們剛剛在定義常數的時候有加上了型別，相信大家在定義的時候知道怎麼加入型別了</p><p>所以就來看一下基本型別有哪些吧！</p><ul><li>整數 Integer</li><li>浮點數 Floating-Point</li><li>布林值 Boolean</li><li>字元 Character</li></ul><h4 id="整數-Integer"><a href="#整數-Integer" class="headerlink" title="整數 Integer"></a>整數 Integer</h4><p>年齡都是用整數來算，用以下範例來舉例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let age: i8 = 18;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>來一一拆解一下</p><p><code>i</code> 指的是 integer<br><code>8</code> 指的是 在記憶體中佔據 8 bits</p><p>如果今天要存取的數字比較大，可以用 <code>32</code> <code>64</code><br>不管是正數還是負數都算在 integer 的型別範圍內</p><p>假設今天要指定這個型別只能為正數，我們需把 <code>i</code> 換成 <code>u</code> 就可以囉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let age: i8 = 18;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果： 18</span><br></pre></td></tr></table></figure><p>如果把它定義成負數會怎樣呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let price: u32 = -100;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ rustc main.rs</span><br><span class="line"></span><br><span class="line">error[E0600]: cannot apply unary operator `-` to type `u32`</span><br><span class="line"> --&gt; main.rs:2:20</span><br><span class="line">  |</span><br><span class="line">2 |   let price: u32 = -100;</span><br><span class="line">  |                    ^^^^ cannot apply unary operator `-`</span><br><span class="line">  |</span><br><span class="line">  = note: unsigned values cannot be negated</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0600`.</span><br></pre></td></tr></table></figure><p>會出現不可以加上 <code>-</code> 的錯誤訊息哦！</p><h4 id="浮點數-Floating-Point"><a href="#浮點數-Floating-Point" class="headerlink" title="浮點數 Floating-Point"></a>浮點數 Floating-Point</h4><p>浮點數有 32 bits 跟 64 bits 兩種選項，小數點後面的位數越多，要使用的 bits 數就要越大 (因為要存在記憶體中)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let product_price: f32 = 5.5;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, product_price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果： 5.5</span><br></pre></td></tr></table></figure><h4 id="布林值-Boolean"><a href="#布林值-Boolean" class="headerlink" title="布林值 Boolean"></a>布林值 Boolean</h4><p>布林值的定義很簡單，只要加上 <code>bool</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let have_fun: bool = true;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, have_fun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果： true</span><br></pre></td></tr></table></figure><h4 id="字元-Character"><a href="#字元-Character" class="headerlink" title="字元 Character"></a>字元 Character</h4><p>我們可以定義任何符號，甚至是數字為字元的型別，型別設定為 <code>char</code> 即可<br>但只能放<code>一個字元</code>喔，後面務必要用<code>單引號</code>，雙引號是用來定義字串的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let money: char = &#x27;$&#x27;;</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, money);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 結果： $</span><br></pre></td></tr></table></figure><p>型別一旦定義後就不能再變了嗎？ Rust 提供了變換型別的方法，下一篇將介紹型別轉換方法！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;淺談-Rust-淵源&quot;&gt;&lt;a href=&quot;#淺談-Rust-淵源&quot; class=&quot;headerlink&quot; title=&quot;淺談 Rust 淵源&quot;&gt;&lt;/a&gt;淺談 Rust 淵源&lt;/h3&gt;&lt;p&gt;Rust 是由 Mozilla 主導開發&lt;/p&gt;
&lt;p&gt;Rust 本來是 M</summary>
      
    
    
    
    <category term="Rust" scheme="http://ninglab.com/categories/Rust/"/>
    
    
  </entry>
  
  <entry>
    <title>AWS 小探險 - 建立 VPC 與 Public Subnet</title>
    <link href="http://ninglab.com/AWS-vpc-and-public-subnet/"/>
    <id>http://ninglab.com/AWS-vpc-and-public-subnet/</id>
    <published>2024-07-25T10:16:22.000Z</published>
    <updated>2024-07-25T11:39:23.173Z</updated>
    
    <content type="html"><![CDATA[<p>全名為 Amazon Virtual Private Cloud，為虛擬的私有雲端，</p><p>當我們的 EC2 (機器) 有多台，並且想對這些機器做區隔的時候，就可以透過 VPC 來達成這個效果</p><p>在 VPC 裡面，會有 Subnet (子網路)，我們可以在 Subnet 底下，架設 EC2</p><p><img src="https://imgur.com/OubK0tQ.jpg" alt="VPC"></p><p>這邊讓大家對於 VPC 先有一點架構概念，接著我們會邊設定邊介紹</p><h2 id="事前作業"><a href="#事前作業" class="headerlink" title="事前作業"></a>事前作業</h2><p>還沒有 AWS 帳號可以先去<a href="https://aws.amazon.com/free/?sc_channel=ps&all-free-tier.sort-by=item.additionalFields.SortRank&all-free-tier.sort-order=asc&awsf.Free%20Tier%20Types=*all&awsf.Free%20Tier%20Categories=*all">官網</a>辦一個</p><h3 id="Step-1-開始架設-VPC"><a href="#Step-1-開始架設-VPC" class="headerlink" title="Step 1. 開始架設 VPC"></a>Step 1. 開始架設 VPC</h3><p>已經有帳號就可以直接進入並且搜尋 VPC</p><p><img src="https://imgur.com/knctqAC.jpg" alt="VPC"></p><p>接著，點選 <code>Create VPC</code></p><p><img src="https://imgur.com/rabYp0t.jpg" alt="VPC"></p><p>接著來設定吧</p><p><code>Resource to create</code> 請選擇 <code>VPC only</code> (但如果你要選 VPC and more 也行，<del>但這樣就不用看這篇文章了</del>)<br><code>Name</code> 填寫 VPC 的名稱<br><code>IPv4 CIDR block</code> 由於我們這次做得不需要用到那麼多 IP，只要一個小範圍就好，因此選擇 <code>IPv4 CIDR manual input</code> 就好<br><code>IPv4 CIDR</code> 填寫他提供的隨機 IP<br><code>IPv6 CIDR block</code> 一樣我們不需要那麼多 IP ，IPv4 就足夠，所以選 <code>No IPv6 CIDR block</code><br><code>Tenancy</code> 我們不需要專用硬體，所以選 <code>Default</code> 即可</p><p><img src="https://imgur.com/CczWhUY.jpg" alt="VPC"></p><p>都填完後，就可以 Create VPC 了</p><p><img src="https://imgur.com/n7tgKYe.jpg" alt="VPC"></p><p>接著我們就可以設定 Subnet 了</p><h3 id="Step-2-設定-Subnet"><a href="#Step-2-設定-Subnet" class="headerlink" title="Step 2. 設定 Subnet"></a>Step 2. 設定 Subnet</h3><p><img src="https://imgur.com/OubK0tQ.jpg" alt="VPC"></p><p>Subnet 分成很多種，先介紹 Public Subnet &#x2F; Private Sunbet 這兩種</p><p>他們都是為在 VPC 裡面的 (詳見架構圖)</p><p><code>Public Subnet</code> 可以透過 Internet Gateway 來跟外網溝通<br><code>Private Subnet</code> 沒辦法透過 Internet Gateway 來跟外網溝通，只能透過 NAT Gateway，且外網沒辦法無法跟 Private Subnet 溝通</p><p>我們先到左邊選單選取 Subnets</p><p><img src="https://imgur.com/yDuh3j0.jpg" alt="Subnet"></p><p>再來點選 <code>Create subnet</code></p><p><img src="https://imgur.com/bGtKTqT.jpg" alt="Subnet"></p><p>點選我們剛剛建立的 <code>VPC ID</code></p><p><img src="https://imgur.com/rEgie9C.jpg" alt="Subnet"></p><p>接著填寫設定</p><p><code>Subnet name</code> 填寫你的 Subnet 名稱(會特別加上 public 讓自己知道這是 Public Subnet)<br><code>Availability Zone</code> 選取離你最近的 AZ<br><code>IPv4 subnet CIDR block</code> 給你的 Subnet 一個 IP 位置，但必須要在 VPC 的 IP 範圍內</p><p><img src="https://imgur.com/5RnOTU4.jpg" alt="Subnet"></p><p>都填寫完就可以 <code>Create subnet</code> 囉</p><p><img src="https://imgur.com/rbafwzY.jpg" alt="Subnet"></p><p>Subnet 建立完成後，我們就要來建立 Internet Gateway</p><h3 id="Step-3-設定-Internet-Gateway"><a href="#Step-3-設定-Internet-Gateway" class="headerlink" title="Step 3. 設定 Internet Gateway"></a>Step 3. 設定 Internet Gateway</h3><p><img src="https://imgur.com/d5PeorZ.jpg" alt="Internet Gateway"></p><p>Internet Gateway 就像對外溝通的橋樑，EC2 必須透過 Internet Gateway 才能跟外網做聯繫</p><p>而 Internet Gateway 是設定在 VPC 上的 (詳見架構圖)</p><p>那我們就來開始吧！</p><p>先在左邊選單點選 Internet gateways</p><p><img src="https://imgur.com/gPUuMXk.jpg" alt="Internet Gateway"></p><p>接著點選 <code>Create internet gateway</code></p><p><img src="https://imgur.com/jH4MOfa.jpg" alt="Internet Gateway"></p><p>填寫 Internet Gateway 的名稱</p><p><img src="https://imgur.com/vj9FOlX.jpg" alt="Internet Gateway"></p><p>再點選 <code>Create internet gateway</code></p><p><img src="https://imgur.com/gooV7Rs.jpg" alt="Internet Gateway"></p><p>這樣就建立成功囉！</p><p>不過我們還要幫他掛在 VPC</p><p>先到右邊 <code>Actions</code> 點選 <code>Attach to VPC</code></p><p><img src="https://imgur.com/05SWK9e.jpg" alt="Internet Gateway"></p><p>接著選取要掛上去的 VPC</p><p><img src="https://imgur.com/NDDjmc2.jpg" alt="Internet Gateway"></p><p>最後點選 <code>Attach internet gateway</code></p><p>Internet Gateway 就設定好了</p><p>不過要讓 EC2 有辦法跟外網溝通，我們還要在 Subnet 的 Route Table 加上 Internet Gateway</p><h3 id="Step-4-設定-Route-Table"><a href="#Step-4-設定-Route-Table" class="headerlink" title="Step 4. 設定 Route Table"></a>Step 4. 設定 Route Table</h3><p><img src="https://imgur.com/odINb6T.jpg" alt="Route Table"></p><p>每個 Subnet 會有一個 Route Table </p><p>Route Table 中會記錄有哪些 Route </p><p>我們先點選到 Subnet </p><p><img src="https://imgur.com/yDuh3j0.jpg" alt="Route Table"></p><p>選取你的 Subnet 後，點選到 Route Table</p><p><img src="https://imgur.com/Mc3ZnQv.jpg" alt="Route Table"></p><p>接著再點選該連結進去</p><p><img src="https://imgur.com/g0E3uTy.jpg" alt="Route Table"></p><p>進入到 Route Table 介面後，再點選連結進入</p><p><img src="https://imgur.com/MdD0pfk.jpg" alt="Route Table"></p><p>點選 <code>Edit routes</code></p><p><img src="https://imgur.com/jkMOEBc.jpg" alt="Route Table"></p><p>再來點 <code>Add route</code> 後填寫設定</p><p><code>Destination</code> 指哪些網路流量可以透過 Internet Gateway 進行溝通，而 <code>0.0.0.0/0</code> 是所有 IPv4 的網路流量<br><code>Target</code> 溝通目標，也就是 Internet Gateway 了，記得選取你剛剛建立的 Internet Gateway</p><p><img src="https://imgur.com/lRDaRNZ.jpg" alt="Route Table"></p><p>按下 <code>Save changes</code> 就完成囉</p><p><img src="https://imgur.com/RJxofkE.jpg" alt="Route Table"></p><p>到這邊我們的架構都設定的差不多囉，接著可以來設定機器 (EC2) 了</p><h3 id="Step-4-建立-EC2"><a href="#Step-4-建立-EC2" class="headerlink" title="Step 4. 建立 EC2"></a>Step 4. 建立 EC2</h3><p><img src="https://imgur.com/2tzVZLV.jpg" alt="EC2"></p><p>每個 Subnet 下都可以放置多台 EC2</p><p>在 EC2 中，我們會將應用程式或專案跑起來</p><p>可以把 EC2 想像成一台電腦，我們要在這台電腦跑起專案或應用程式</p><p>開始來建立吧！點選 <code>EC2</code></p><p><img src="https://imgur.com/1Iitjpz.jpg" alt="EC2"></p><p>接著點選 <code>Launch instance</code></p><p><img src="https://imgur.com/Xf7hsBE.jpg" alt="EC2"></p><p>填寫 instance 的名字</p><p><img src="https://imgur.com/c4EB0D2.jpg" alt="EC2"></p><p>選取該機器要用的系統 (通常我都選 Amazon Linux ，並且使用免費方案可用的 image)</p><p><img src="https://imgur.com/AYVlp8B.jpg" alt="EC2"></p><p>Instance type 選取專案適用的規格(專案小就可以選免費方案可用的)</p><p><img src="https://imgur.com/dl49XeD.jpg" alt="EC2"></p><p>建立金鑰，並下載 (登入 ssh 的時候驗證用)</p><p><img src="https://imgur.com/bHQYaEe.jpg" alt="EC2"></p><p>機器的設定就差不多到這邊，接著下面有 Network Settings 區塊</p><p>我們就要進入設定 Network 與 Security Group 囉</p><h3 id="Step-5-設定-Network-與-Security-Group"><a href="#Step-5-設定-Network-與-Security-Group" class="headerlink" title="Step 5. 設定 Network 與 Security Group"></a>Step 5. 設定 Network 與 Security Group</h3><p><img src="https://imgur.com/AZmZ9nt.jpg" alt="EC2"></p><p>Network 是綁在 Subnet 上的，而 Security Group 是管控 Network 網際網路協議存取權限的 (不是管 EC2 的喔！！！)</p><p>EC2 透過該 Network 才會有 IP 並且跟外網溝通</p><p>我們選取剛剛建立的 VPC &#x2F; Subnet</p><p>並且給這個 EC2 一個公開的 IP ，好方便跟外網做聯繫</p><p><img src="https://imgur.com/e8KAXNj.jpg" alt="EC2"></p><p>當 Network 設定完成後，我們要幫這個 Network 設定 <code>Security Group</code></p><p>來管理網際網路協議的存取權限</p><p>因為之前沒有建立過 Security Group </p><p>所以我們這次就建立一個新的，並給他一個名稱及描述</p><p>接著我們要來看 Inbound Security Group Rule</p><p>所謂的 Inbound 指的是外部要連進來的流量</p><p>OutBound 指的是內部要出去的流量</p><p><img src="https://imgur.com/D4kGVhl.jpg" alt="EC2"></p><p>預設會帶 ssh ，這也是為什麼我們可以透過 ssh 可以進入到機器中</p><p>我們今天只有要試試是否能 ping 到 EC2 的 IP，所以只要設定 All ICMP - IPv4</p><p>如果是要讓其他使用者存取到該應用程式，或者使用該網頁，就需要設定 TCP 這個網際網路協議</p><p>因為我們要讓外部所有地方都可以 ping 到，所以 Source Type 為 Anywhere</p><p>Source 就會自動帶 0.0.0.0&#x2F;0 囉</p><p><img src="https://imgur.com/W2q2c71.jpg" alt="EC2"></p><p>如果沒有額外要設定的，就可以到右方的 Launch Instance 建立 EC2 了</p><p>到這邊基本上就完成了 VPC &amp; Public Subnet &amp; EC2 的建立囉</p><p>我們來看一下架構圖，就可以接著去試試 ping IP 了</p><p><img src="https://imgur.com/AZmZ9nt.jpg" alt="EC2"></p><h3 id="Step-6-進入機器-外部-ping-機器-IP"><a href="#Step-6-進入機器-外部-ping-機器-IP" class="headerlink" title="Step 6. 進入機器 &amp; 外部 ping 機器 IP"></a>Step 6. 進入機器 &amp; 外部 ping 機器 IP</h3><p>先到 EC2 並且點選 <code>connect</code></p><p><img src="https://imgur.com/bW4X3Ca.jpg" alt="EC2"></p><p>我們來透過本地的終端機進入機器(不過要直接從 EC2 console 進去也可以唷)，點選 <code>SSH client</code></p><p>接著在終端機先到剛剛下載金鑰的地方，下指令</p><p><code>chmod 400 &quot;0722.pem&quot;</code></p><p>改變該 pem 的權限為只有所有者能讀</p><p>接著輸入指令進入 EC2，並且同意繼續連線</p><p><code>ssh -i &quot;0722.pem&quot; ec2-user@54.180.247.118</code></p><p><img src="https://imgur.com/UvsVMuI.jpg" alt="EC2"></p><p>接著就進入到機器中了，我們可以在機器中去 ping 外部的網路，以 google IP 為例</p><p>當你收到 xxx bytes from 8.8.8.8 ，並且有回應時間時，就代表成功囉</p><p><img src="https://imgur.com/mM3VjvK.jpg" alt="EC2"></p><p>接著我們可以離開機器，在一般的終端機中 ping 機器的 ip</p><p>機器的 ip 哪裡看，在剛剛 <code>SSH client</code></p><p><img src="https://imgur.com/4L1j1p1.jpg" alt="EC2"></p><p>接著輸入 <code>ping 54.180.247.118</code> ，有回應時間就可以囉</p><p><img src="https://imgur.com/N420Mfx.jpg" alt="EC2"></p><p>在 AWS 架設服務是會被收錢的唷，</p><p>分別要</p><ol><li>關掉 EC2 </li><li>刪除 VPC (刪除後需要檢查一下 VPC &#x2F; Subnet &#x2F; Internet Gateway &#x2F; Route Table &#x2F; Network ACLs ) </li><li>釋放 IP address  (在 EC2 左邊選單的 Elastic IP addresses，點進去把 IP release 即可)</li></ol><p>上面步驟可以參照官方文件去做</p><p>以上若有任何疑問或指教也歡迎留言！有幫助的話也歡迎給個讚，謝謝！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;全名為 Amazon Virtual Private Cloud，為虛擬的私有雲端，&lt;/p&gt;
&lt;p&gt;當我們的 EC2 (機器) 有多台，並且想對這些機器做區隔的時候，就可以透過 VPC 來達成這個效果&lt;/p&gt;
&lt;p&gt;在 VPC 裡面，會有 Subnet (子網路)，我們可以</summary>
      
    
    
    
    <category term="AWS" scheme="http://ninglab.com/categories/AWS/"/>
    
    
  </entry>
  
  <entry>
    <title>Django - LINE Pay 串接實戰</title>
    <link href="http://ninglab.com/Django-line-pay/"/>
    <id>http://ninglab.com/Django-line-pay/</id>
    <published>2024-06-09T19:11:18.000Z</published>
    <updated>2024-06-09T19:41:19.017Z</updated>
    
    <content type="html"><![CDATA[<p>LINE Pay 已經是現在大眾很習慣的付款方式</p><p>不過目前用 Django 串接 LINE Pay 的資源很少</p><p>所以今天想跟大家分享如何在 Django 中串接 LINE Pay</p><p>分成以下四個步驟</p><ol><li>申請 SandBox 帳號密碼</li><li>申請 Channel ID &amp; Key</li><li>串接 Request</li><li>串接 Confirm</li></ol><p>因為目前還沒有正式的商店，所以就先用 Sandbox </p><ul><li>使用 LinePay v3</li></ul><h3 id="GitHub-參考"><a href="#GitHub-參考" class="headerlink" title="GitHub 參考"></a>GitHub 參考</h3><p><a href="https://github.com/cacachang/django_line_pay">https://github.com/cacachang/django_line_pay</a></p><h2 id="Step-1-LINE-Pay-相關申請"><a href="#Step-1-LINE-Pay-相關申請" class="headerlink" title="Step 1. LINE Pay 相關申請"></a>Step 1. LINE Pay 相關申請</h2><p>至 <a href="https://pay.line.me/tw/developers/techsupport/sandbox/creation?locale=zh_TW">LINE Pay Developers</a> 申請建立 Sandbox<br>填寫完畢後，至 Mail 收信拿 Sandbox 帳號密碼</p><p><img src="https://imgur.com/3G965Ag.jpg" alt="LINE Pay Sandbox"></p><p>登入 <a href="https://pay.line.me/portal/tw/auth/login">LINE Pay 後台</a></p><p><img src="https://imgur.com/FaMU0kZ.jpg" alt="LINE Pay"></p><p>登入成功後，進入後台申請 Channel ID &amp; Channel Secret Key</p><p>收到 Mail，填入驗證碼後就可以拿到 Channel ID &amp; Channel Secret Key</p><p><img src="https://imgur.com/HpA6RUG.jpg" alt="LINE Pay"></p><p>將 Channel ID &amp; Channel Secret Key 放到環境變數中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># .env</span><br><span class="line"></span><br><span class="line">LINE_CHANNEL_ID=xxxxxxxx</span><br><span class="line">LINE_CHANNEL_SECRET_KEY=xxxxxxxx</span><br></pre></td></tr></table></figure><h2 id="Step-2-向-LINE-Pay-請求付款資訊"><a href="#Step-2-向-LINE-Pay-請求付款資訊" class="headerlink" title="Step 2. 向 LINE Pay 請求付款資訊"></a>Step 2. 向 LINE Pay 請求付款資訊</h2><p>我們要使用 LINE Pay 來做付款，</p><p>請求付款是要打 Request API </p><p>所以我們必須要發送 request 到該 API</p><h4 id="設定-urls-與-views"><a href="#設定-urls-與-views" class="headerlink" title="設定 urls 與 views"></a>設定 urls 與 views</h4><p>金流的資料相對比較機密，我會採用後端的方式去打 API </p><p>所以我們就需要設定一個 urls 與 views </p><p>當使用者按下結帳按鈕時，就會至該網址，並且於 views 發送 request 給 LINE Pay</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># payment/urls.py</span><br><span class="line"></span><br><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">app_name = &quot;payment&quot;</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;request&#x27;, views.request, name=&#x27;request&#x27;),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>記得也要加入 templates</p><h4 id="組裝-request-需要的-headers-body"><a href="#組裝-request-需要的-headers-body" class="headerlink" title="組裝 request 需要的 headers &amp; body"></a>組裝 request 需要的 headers &amp; body</h4><p>官方手冊 Request API 的規格</p><p>方法 <code>POST</code><br>URL <code>/v3/payments/request</code></p><p>headers 會需要 body 的資料，所以我們就先來建立 body</p><h4 id="建立-body"><a href="#建立-body" class="headerlink" title="建立 body"></a>建立 body</h4><p>這邊我們先建立必填的 items</p><p><img src="https://imgur.com/CNHLU4F.jpg" alt="LINE Pay body"></p><p>items 之多，圖片不及備載，如果有額外需求，可以至<a href="https://pay.line.me/tw/developers/apis/onlineApis?locale=zh_TW">官方手冊</a>翻相關的 items 並加入</p><p>接下來我們就先來做 body 吧</p><p>基本的總額 &#x2F; 幣別，是串金流非常基本的參數，這邊就不多做介紹</p><p><code>orderId</code> 需放訂單的 <code>id</code>，到時候 API 打回來的 response 會有 orderId 讓我們去找到該 order </p><ul><li>文章用所以先用 uuid 來代替，在專案上請使用訂單的 id 來取代</li></ul><p><code>packages</code> 把他當成商品組合，要塞該商品的 id 以及總額，如果不是組合的話，<code>package_id</code> 可以用 uuid 帶過即可，<code>products</code> 則是組合中的商品們</p><p><code>redirectUrls</code> 在我們發送 request 出去後，取消付款以及付款確認後要轉回來的網址</p><ul><li>HOSTNAME 環境變數可以使用 NGROK 或網域</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from django.utils import timezone</span><br><span class="line">from pathlib import Path</span><br><span class="line">from django.shortcuts import redirect</span><br><span class="line">import os</span><br><span class="line">import uuid</span><br><span class="line">import environ</span><br><span class="line"></span><br><span class="line">BASE_DIR = Path(__file__).resolve().parent.parent</span><br><span class="line">env = environ.Env()</span><br><span class="line">environ.Env.read_env(os.path.join(BASE_DIR, &#x27;.env&#x27;))</span><br><span class="line"></span><br><span class="line">def request(request):</span><br><span class="line">    if request.method == &quot;POST&quot;:</span><br><span class="line">        order_id = f&quot;order_&#123;str(uuid.uuid4())&#125;&quot;</span><br><span class="line">        package_id = f&quot;package_&#123;str(uuid.uuid4())&#125;&quot;</span><br><span class="line"></span><br><span class="line">        payload = &#123;</span><br><span class="line">            &#x27;amount&#x27;: 100,</span><br><span class="line">            &#x27;currency&#x27;: &#x27;TWD&#x27;,</span><br><span class="line">            &#x27;orderId&#x27;: order_id,</span><br><span class="line">            &#x27;packages&#x27;: [&#123;</span><br><span class="line">                &#x27;id&#x27;: package_id,</span><br><span class="line">                &#x27;amount&#x27;: 100,</span><br><span class="line">                &#x27;products&#x27;: [&#123;</span><br><span class="line">                    &#x27;id&#x27;: &#x27;1&#x27;,</span><br><span class="line">                    &#x27;name&#x27;: &#x27;測試商品&#x27;,</span><br><span class="line">                    &#x27;quantity&#x27;: 1,</span><br><span class="line">                    &#x27;price&#x27;: 100,</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;],</span><br><span class="line">            &#x27;redirectUrls&#x27;: &#123;</span><br><span class="line">                &#x27;confirmUrl&#x27;: f&quot;https://&#123;env(&#x27;HOSTNAME&#x27;)&#125;/payment/confirm&quot;,</span><br><span class="line">                &#x27;cancelUrl&#x27;: f&quot;https://&#123;env(&#x27;HOSTNAME&#x27;)&#125;/payment/cancel&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        return render(request, &quot;payment/checkout.html&quot;)</span><br></pre></td></tr></table></figure><h4 id="建立-headers"><a href="#建立-headers" class="headerlink" title="建立 headers"></a>建立 headers</h4><p>當我們把 body 做好後，就該來做 headers 了</p><p>先來看一下官方手冊吧</p><p><code>Content-Type</code> 指的是使用的資料格式<br><code>X-LINE-ChannelId</code> 填入剛剛申請的 Channel ID，這樣才知道是哪間商店<br><code>X-LINE-MerchantDeviceProfileId</code> 目前沒有實體店，略過<br><code>X-LINE-Authorization-Nonce</code> 是為了避免搞混多筆一樣的交易，所以多這個參數<br><code>X-LINE-Authorization</code> Hash 過後的交易及其他資料(包含 body)</p><p><img src="https://imgur.com/1DsAdiO.jpg" alt="LINE Pay Request Header"></p><p>我們先列出 header 必要的 key </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def create_headers(body, uri):</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">        &#x27;X-LINE-ChannelId&#x27;: &#x27;&#x27;,</span><br><span class="line">        &#x27;X-LINE-Authorization-Nonce&#x27;: &#x27;&#x27;,</span><br><span class="line">        &#x27;X-LINE-Authorization&#x27;: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return headers</span><br></pre></td></tr></table></figure><h4 id="X-LINE-ChannelId"><a href="#X-LINE-ChannelId" class="headerlink" title="X-LINE-ChannelId"></a>X-LINE-ChannelId</h4><p>接著我們將 Channel Id 從環境變數取出作為 <code>X-LINE-ChannelId</code> 的 value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def create_headers(body, uri):</span><br><span class="line">    channel_id = env(&#x27;LINE_CHANNEL_ID&#x27;)</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">        &#x27;X-LINE-ChannelId&#x27;: channel_id,</span><br><span class="line">        &#x27;X-LINE-Authorization-Nonce&#x27;: &#x27;&#x27;,</span><br><span class="line">        &#x27;X-LINE-Authorization&#x27;: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return headers</span><br></pre></td></tr></table></figure><h4 id="X-LINE-Authorization-Nonce"><a href="#X-LINE-Authorization-Nonce" class="headerlink" title="X-LINE-Authorization-Nonce"></a>X-LINE-Authorization-Nonce</h4><p>再來製作一個 nonce ，目的在於區別各個交易</p><p>我們就用 uuid 來做吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def create_headers(body, uri):</span><br><span class="line">    ...</span><br><span class="line">    nonce = str(uuid.uuid4())</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">        &#x27;X-LINE-ChannelId&#x27;: channel_id,</span><br><span class="line">        &#x27;X-LINE-Authorization-Nonce&#x27;: nonce,</span><br><span class="line">        &#x27;X-LINE-Authorization&#x27;: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return headers</span><br></pre></td></tr></table></figure><h4 id="X-LINE-Authorization"><a href="#X-LINE-Authorization" class="headerlink" title="X-LINE-Authorization"></a>X-LINE-Authorization</h4><p>headers 中以 <code>X-LINE-Authorization</code> 處理起來比較耗費心力一點</p><p>我們先來看一下官方手冊給的公式</p><blockquote><p>Signature &#x3D; Base64(HMAC-SHA256(Your ChannelSecret, (Your ChannelSecret + URI + RequestBody + nonce)))</p></blockquote><p><code>Your ChannelSecret</code> 是我們剛剛申請的 Channel Secret Key </p><p><code>URI</code> 由於我們是打 Request API，所以這邊指的是 <code>/v3/payments/request</code><br><strong>要注意，不需要加上 Sandbox 的 URL</strong></p><p><code>RequestBody</code> 我們剛剛組合的 body (也就是 payload)</p><p><code>nonce</code> 可使用 uuid 或 timestamp 產生</p><p>我們先將這四個資料找出來，並且串起來</p><h4 id="secret-key"><a href="#secret-key" class="headerlink" title="secret_key"></a>secret_key</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def create_headers(body, uri):</span><br><span class="line">    ...</span><br><span class="line">    secret_key = env(&#x27;LINE_CHANNEL_SECRET_KEY&#x27;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">        &#x27;X-LINE-ChannelId&#x27;: channel_id,</span><br><span class="line">        &#x27;X-LINE-Authorization-Nonce&#x27;: nonce,</span><br><span class="line">        &#x27;X-LINE-Authorization&#x27;: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return headers</span><br></pre></td></tr></table></figure><h4 id="uri-body"><a href="#uri-body" class="headerlink" title="uri &#x2F; body"></a>uri &#x2F; body</h4><p>由於 Confirm API 也會需要用該方法建立 header </p><p>所以 body 與 uri 就用引數</p><p>我們要在呼叫 <code>create_headers</code> 方法時帶入</p><p>uri 已經存在環境變數 <code>LINE_SIGNATURE_REQUEST_URI</code>中了，所以將他叫出來即可，要注意值是 <code>/v3/payments/request</code></p><p>body 則是我們一開始組裝的 payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def request(request):</span><br><span class="line">    if request.method == &quot;POST&quot;:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        payload = &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        signature_uri = env(&#x27;LINE_SIGNATURE_REQUEST_URI&#x27;)        </span><br><span class="line">        headers = create_headers(payload, signature_uri)</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        return render(request, &quot;payment/checkout.html&quot;)</span><br></pre></td></tr></table></figure><p>因為 headers 的 Content-Type 格式是 application&#x2F;json<br>所以當 body 要記得轉成 json 格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">def create_headers(body, uri):</span><br><span class="line">    ...</span><br><span class="line">    body_to_json = json.dumps(body)</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">        &#x27;X-LINE-ChannelId&#x27;: channel_id,</span><br><span class="line">        &#x27;X-LINE-Authorization-Nonce&#x27;: nonce,</span><br><span class="line">        &#x27;X-LINE-Authorization&#x27;: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return headers</span><br></pre></td></tr></table></figure><h4 id="nonce"><a href="#nonce" class="headerlink" title="nonce"></a>nonce</h4><p>我們可以用剛剛做出來的 nonce ，這邊就不需要再另外做了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def create_headers(body, uri):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">        &#x27;X-LINE-ChannelId&#x27;: channel_id,</span><br><span class="line">        &#x27;X-LINE-Authorization-Nonce&#x27;: nonce,</span><br><span class="line">        &#x27;X-LINE-Authorization&#x27;: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return headers</span><br></pre></td></tr></table></figure><h4 id="組裝成-message"><a href="#組裝成-message" class="headerlink" title="組裝成 message"></a>組裝成 message</h4><p>Signature 公式</p><blockquote><p>Signature &#x3D; Base64(HMAC-SHA256(Your ChannelSecret, (Your ChannelSecret + URI + RequestBody + nonce)))</p></blockquote><p>四個資料都準備好後，就可以把他們組裝起來了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def create_headers(body, uri):</span><br><span class="line">    ...</span><br><span class="line">    nonce = str(uuid.uuid4())</span><br><span class="line">    secret_key = env(&#x27;LINE_CHANNEL_SECRET_KEY&#x27;)</span><br><span class="line">    body_to_json = json.dumps(body)</span><br><span class="line">    message = secret_key + uri + body_to_json + nonce</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">        &#x27;X-LINE-ChannelId&#x27;: channel_id,</span><br><span class="line">        &#x27;X-LINE-Authorization-Nonce&#x27;: nonce,</span><br><span class="line">        &#x27;X-LINE-Authorization&#x27;: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return headers</span><br></pre></td></tr></table></figure><h4 id="對-message-及-secret-key-做-hash"><a href="#對-message-及-secret-key-做-hash" class="headerlink" title="對 message 及 secret_key 做 hash"></a>對 message 及 secret_key 做 hash</h4><p>我們再來看一下官方手冊給的公式</p><blockquote><p>Signature &#x3D; Base64(HMAC-SHA256(Your ChannelSecret, (Your ChannelSecret + URI + RequestBody + nonce)))</p></blockquote><p>組起來後我們就要先來對這包資料做 HMAC</p><p>HMAC 是一種雜湊方式，可以保有完整資料，而且也可以拿來做身份的驗證</p><p>我們在傳送資料的過程中，隨時有可能會被有心人士更改，</p><p>將資料加上雜湊，可以讓資料難以被更改以外</p><p>也可以透過解析來做身份驗證<br>(判斷接收方與發送方計算出來的是否一致)</p><p>由於 hmac 方法只接受 bytes 或 bytearray 資料</p><h4 id="改資料為-bytes"><a href="#改資料為-bytes" class="headerlink" title="改資料為 bytes"></a>改資料為 bytes</h4><p>所以我們得先將 secret_key 與 message 轉為 bytes 格式</p><p><code>encode</code> 會將字串轉換格式，預設是轉換為 <code>utf-8</code> </p><p>UTF-8 編碼是將字串轉為位元組的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def create_headers(body, uri):</span><br><span class="line">    ...</span><br><span class="line">    secret_key = env(&#x27;LINE_CHANNEL_SECRET_KEY&#x27;)</span><br><span class="line">    body_to_json = json.dumps(body)</span><br><span class="line">    nonce = str(uuid.uuid4())</span><br><span class="line">    message = secret_key + uri + body_to_json + nonce</span><br><span class="line">    </span><br><span class="line">    binary_message = message.encode()</span><br><span class="line">    binary_secret_key = secret_key.encode()</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">        &#x27;X-LINE-ChannelId&#x27;: channel_id,</span><br><span class="line">        &#x27;X-LINE-Authorization-Nonce&#x27;: nonce,</span><br><span class="line">        &#x27;X-LINE-Authorization&#x27;: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return headers</span><br></pre></td></tr></table></figure><h4 id="HMAC-處理"><a href="#HMAC-處理" class="headerlink" title="HMAC 處理"></a>HMAC 處理</h4><p>Signature 公式</p><blockquote><p>Signature &#x3D; Base64(HMAC-SHA256(Your ChannelSecret, (Your ChannelSecret + URI + RequestBody + nonce)))</p></blockquote><p>hmac 第一個引數為 key ，這邊我們要放 binary_secret_key</p><p>第二個引數為 message，要放 binary_message</p><p>第三個引數為雜湊模式，要用 SHA256 的方式雜湊，第三個參數要加上 <code>hashlib.sha256</code></p><blockquote><p>hmac.new(key, msg&#x3D;None, digestmod)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">import hmac</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">def create_headers(body, uri):</span><br><span class="line">    ...</span><br><span class="line">    secret_key = env(&#x27;LINE_CHANNEL_SECRET_KEY&#x27;)</span><br><span class="line">    body_to_json = json.dumps(body)</span><br><span class="line">    nonce = str(uuid.uuid4())</span><br><span class="line">    message = secret_key + uri + body_to_json + nonce</span><br><span class="line">    </span><br><span class="line">    binary_message = message.encode()</span><br><span class="line">    binary_secret_key = secret_key.encode()</span><br><span class="line">    </span><br><span class="line">    hash = hmac.new(binary_secret_key, binary_message, hashlib.sha256)</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">        &#x27;X-LINE-ChannelId&#x27;: channel_id,</span><br><span class="line">        &#x27;X-LINE-Authorization-Nonce&#x27;: nonce,</span><br><span class="line">        &#x27;X-LINE-Authorization&#x27;: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return headers</span><br></pre></td></tr></table></figure><h4 id="Base-64"><a href="#Base-64" class="headerlink" title="Base 64"></a>Base 64</h4><p>Signature 公式</p><blockquote><p>Signature &#x3D; Base64(HMAC-SHA256(Your ChannelSecret, (Your ChannelSecret + URI + RequestBody + nonce)))</p></blockquote><p>Base64常用於處理文字資料，可用來傳輸</p><p>如想了解更細部的資訊，可參閱 <a href="xhttps://zh.wikipedia.org/wiki/Base64">Base64</a></p><p>做好就可以作為 <code>X-LINE-Authorization</code> 的 value 了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">import base64</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">def create_headers(body, uri):</span><br><span class="line">    ...</span><br><span class="line">    secret_key = env(&#x27;LINE_CHANNEL_SECRET_KEY&#x27;)</span><br><span class="line">    body_to_json = json.dumps(body)</span><br><span class="line">    nonce = str(uuid.uuid4())</span><br><span class="line">    message = secret_key + uri + body_to_json + nonce</span><br><span class="line">    </span><br><span class="line">    binary_message = message.encode()</span><br><span class="line">    binary_secret_key = secret_key.encode()</span><br><span class="line">    </span><br><span class="line">    hash = hmac.new(binary_secret_key, binary_message, hashlib.sha256)</span><br><span class="line">    </span><br><span class="line">    signature = base64.b64encode(hash.digest()).decode()</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">        &#x27;X-LINE-ChannelId&#x27;: channel_id,</span><br><span class="line">        &#x27;X-LINE-Authorization-Nonce&#x27;: nonce,</span><br><span class="line">        &#x27;X-LINE-Authorization&#x27;: signature</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return headers</span><br></pre></td></tr></table></figure><h4 id="打-API-囉！"><a href="#打-API-囉！" class="headerlink" title="打 API 囉！"></a>打 API 囉！</h4><p>我們將 headers 處理好後，</p><p>接著將 body 轉為 json </p><p>並且設定好要打的 url (請用環境變數存放) 為 <code>https://sandbox-api-pay.line.me/v3/payments/request</code></p><p>就可以打 API 出去了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">def request(request):</span><br><span class="line">    if request.method == &quot;POST&quot;:</span><br><span class="line">        url = f&quot;&#123;env(&#x27;LINE_SANDBOX_URL&#x27;)&#125;&#123;env(&#x27;LINE_REQUEST_URL&#x27;)&#125;&quot;</span><br><span class="line">        ...</span><br><span class="line">        body = json.dumps(payload)</span><br><span class="line"></span><br><span class="line">        response = requests.post(url, headers=headers, data=body)</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        return render(request, &quot;payment/checkout.html&quot;)</span><br></pre></td></tr></table></figure><h3 id="接收-response"><a href="#接收-response" class="headerlink" title="接收 response"></a>接收 response</h3><p>打過去 Request API 後，會回傳一包 response </p><p>這時候 LINE Pay 的付款頁面就會在這包裡面</p><p>我們要將 response 解析</p><p>成功的回傳代碼是 <code>0000</code></p><p>如成功的話，將頁面網址找出來再 redirect 過去</p><p>失敗的話就印出回傳訊息</p><p>而付款頁面是放在 info 的 paymentUrl 的 web</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def request(request):</span><br><span class="line">    if request.method == &quot;POST&quot;:</span><br><span class="line">        url = f&quot;&#123;env(&#x27;LINE_SANDBOX_URL&#x27;)&#125;&#123;env(&#x27;LINE_REQUEST_URL&#x27;)&#125;&quot;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        response = requests.post(url, headers=headers, data=body)</span><br><span class="line">        </span><br><span class="line">        if response.status_code == 200:</span><br><span class="line">            data = response.json()</span><br><span class="line">            if data[&#x27;returnCode&#x27;] == &#x27;0000&#x27;:</span><br><span class="line">                return redirect(data[&#x27;info&#x27;][&#x27;paymentUrl&#x27;][&#x27;web&#x27;])</span><br><span class="line">            else:</span><br><span class="line">                print(data[&#x27;returnMessage&#x27;])</span><br><span class="line">                return render(request, &quot;payment/checkout.html&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(f&#x27;Error: &#123;response.status_code&#125;&#x27;)</span><br><span class="line">            return render(request, &quot;payment/checkout.html&quot;)</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        return render(request, &quot;payment/checkout.html&quot;)</span><br></pre></td></tr></table></figure><h3 id="設定-CSRF-以及-ALLOWED-HOST"><a href="#設定-CSRF-以及-ALLOWED-HOST" class="headerlink" title="設定 CSRF 以及 ALLOWED_HOST"></a>設定 CSRF 以及 ALLOWED_HOST</h3><p>由於我這邊使用 NGROK ，是外部的服務</p><p>除了要告訴 Djanog 哪些域名是可以被訪問的以外</p><p>還要避免偽造請求</p><p>所以需要再額外設定 CSRF 與 ALLOWED_HOST</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># core/settings.py</span><br><span class="line"></span><br><span class="line">ALLOWED_HOSTS = [</span><br><span class="line">    env(&#x27;HOSTNAME&#x27;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">CSRF_TRUSTED_ORIGINS = [</span><br><span class="line">    f&quot;https://&#123;env(&#x27;HOSTNAME&#x27;)&#125;&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>到這邊應該就可以前進 LINE Pay 付款了</p><p><img src="https://imgur.com/y5sCFQa.jpg" alt="LINE Pay"></p><p>手機掃描付款畫面</p><p><img src="https://imgur.com/OoA0eWb.jpg" alt="LINE Pay"></p><h2 id="Step-3-向-LINE-Pay-申請完成交易"><a href="#Step-3-向-LINE-Pay-申請完成交易" class="headerlink" title="Step 3. 向 LINE Pay 申請完成交易"></a>Step 3. 向 LINE Pay 申請完成交易</h2><p>付款申請差不多到這邊，接著消費者完成交易後，店家這邊需要再做確認</p><p>所以再來要打 Confirm API</p><p>由於處理方式跟 Request API 差不多，類似的地方我就不多做介紹</p><h4 id="設定-urls-與-views-1"><a href="#設定-urls-與-views-1" class="headerlink" title="設定 urls 與 views"></a>設定 urls 與 views</h4><p>一樣設定 urls 與 views </p><p>當使用者付款成功後，會馬上轉到 confirm 的 url 去完成交易</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># payment/urls.py</span><br><span class="line"></span><br><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">app_name = &quot;payment&quot;</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;request&#x27;, views.request, name=&#x27;request&#x27;),</span><br><span class="line">    path(&#x27;confirm&#x27;, views.confirm, name=&quot;confirm&quot;),</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>記得也要加入 templates</p><h4 id="組裝-request-需要的-headers-body-1"><a href="#組裝-request-需要的-headers-body-1" class="headerlink" title="組裝 request 需要的 headers &amp; body"></a>組裝 request 需要的 headers &amp; body</h4><p>官方手冊 Request API 的規格</p><p>方法 <code>POST</code><br>URL <code>/v3/payments/&#123;transactionId&#125;/confirm</code></p><p>在組裝 headers 與 body 以前，我們要先拿到該筆交易的 id 讓 LINE Pay 與我們辨認</p><h3 id="拿到-transaction-id-與-order-id"><a href="#拿到-transaction-id-與-order-id" class="headerlink" title="拿到 transaction_id 與 order_id"></a>拿到 transaction_id 與 order_id</h3><p>Confirm API 的 url 需要包含 transaction_id </p><p>LINE Pay 才會知道是要確認哪筆款項</p><p>所以我們要從 requests 中找到 <code>transactionId</code></p><p>orderId 則是方便我們從資料庫中找出資料，並針對該訂單進行更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def confirm(request):</span><br><span class="line">    transaction_id = request.GET.get(&#x27;transactionId&#x27;)</span><br><span class="line">    order_id = request.GET.get(&#x27;orderId&#x27;)</span><br></pre></td></tr></table></figure><h3 id="組裝-body"><a href="#組裝-body" class="headerlink" title="組裝 body"></a>組裝 body</h3><p>打 Confirm API 一樣需要組裝 body </p><p>只要包含 amount 與 currency 即可</p><p>這邊需要去資料庫中撈出該筆 order_id 的資料，並且將 amount 填進去</p><p>不過展示所以就先寫假資料</p><p><img src="https://imgur.com/sUfSctm.jpg" alt="LINE Pay Confirm"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def confirm(request):</span><br><span class="line">    transaction_id = request.GET.get(&#x27;transactionId&#x27;)</span><br><span class="line">    order_id = request.GET.get(&#x27;orderId&#x27;)</span><br><span class="line">    </span><br><span class="line">    payload = &#123;</span><br><span class="line">        &#x27;amount&#x27;: 100,</span><br><span class="line">        &#x27;currency&#x27;: &#x27;TWD&#x27;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="建立-headers-1"><a href="#建立-headers-1" class="headerlink" title="建立 headers"></a>建立 headers</h3><p>跟剛剛的 Request API 一樣</p><p>只要將 body 與 uri 做為參數傳進去即可</p><p>要記得 uri 要塞 transaction_id 進去 <code>/v3/payments/&#123;transaction_id&#125;/confirm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def confirm(request):</span><br><span class="line">    transaction_id = request.GET.get(&#x27;transactionId&#x27;)</span><br><span class="line">    order_id = request.GET.get(&#x27;orderId&#x27;)</span><br><span class="line">    </span><br><span class="line">    payload = &#123;</span><br><span class="line">        &#x27;amount&#x27;: 100,</span><br><span class="line">        &#x27;currency&#x27;: &#x27;TWD&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    signature_uri = f&quot;/v3/payments/&#123;transaction_id&#125;/confirm&quot;</span><br><span class="line">    headers = create_headers(payload, signature_uri)</span><br></pre></td></tr></table></figure><h3 id="發送-reqeust-到-Confirm-API"><a href="#發送-reqeust-到-Confirm-API" class="headerlink" title="發送 reqeust 到 Confirm API"></a>發送 reqeust 到 Confirm API</h3><p>將 body 轉成 json 格式後</p><p>設定 url 後，就可以打 API 過去了</p><p>url 的網址為 <code>https://sandbox-api-pay.line.me/v3/payments/&#123;transaction_id&#125;/confirm</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def confirm(request):</span><br><span class="line">    transaction_id = request.GET.get(&#x27;transactionId&#x27;)</span><br><span class="line">    order_id = request.GET.get(&#x27;orderId&#x27;)</span><br><span class="line">    url = f&quot;&#123;env(&#x27;LINE_SANDBOX_URL&#x27;)&#125;/v3/payments/&#123;transaction_id&#125;/confirm&quot;</span><br><span class="line">    </span><br><span class="line">    body = json.dumps(payload)</span><br><span class="line"></span><br><span class="line">    response = requests.post(uri, headers=headers, data=body)</span><br></pre></td></tr></table></figure><h4 id="解析-response"><a href="#解析-response" class="headerlink" title="解析 response"></a>解析 response</h4><p>這邊的步驟也跟 Request API 一樣</p><p><code>returnCode</code> 成功為 <code>0000</code></p><p>如果是 0000 的話就轉到付款成功頁面</p><p>失敗就轉至失敗頁面，並可設定錯誤訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># payment/views.py</span><br><span class="line"></span><br><span class="line">def confirm(request):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    response = requests.post(uri, headers=headers, data=body)</span><br><span class="line">    </span><br><span class="line">    data = response.json()</span><br><span class="line">    if data[&#x27;returnCode&#x27;] == &#x27;0000&#x27;:</span><br><span class="line">        return render(request, &quot;payment/success.html&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(data[&#x27;returnMessage&#x27;])</span><br><span class="line">        return render(request, &quot;payment/fail.html&quot;)</span><br></pre></td></tr></table></figure><p>到這邊就差不多囉，接著就把 success 與 fail 的 urls &#x2F; views &#x2F; templates 補上就可以囉</p><p>如果我們一開始在打 Request API 的時候沒有設定 options.payment.capture 為 false 的話，到這步就完成了</p><p>如果設定為 false 的話，狀態會保持 <code>待請款（授權）</code> ，必須要再打 <code>Capture API</code></p><p>如果這篇文章對你有幫助的話，歡迎按讚或留言</p><p>有任何想討論的，也歡迎底下留言給我唷</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;LINE Pay 已經是現在大眾很習慣的付款方式&lt;/p&gt;
&lt;p&gt;不過目前用 Django 串接 LINE Pay 的資源很少&lt;/p&gt;
&lt;p&gt;所以今天想跟大家分享如何在 Django 中串接 LINE Pay&lt;/p&gt;
&lt;p&gt;分成以下四個步驟&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;申請 S</summary>
      
    
    
    
    <category term="Django" scheme="http://ninglab.com/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>Python - 實體方法與類別方法的小故事</title>
    <link href="http://ninglab.com/Python-methods/"/>
    <id>http://ninglab.com/Python-methods/</id>
    <published>2024-05-26T12:48:51.000Z</published>
    <updated>2024-05-26T16:23:08.016Z</updated>
    
    <content type="html"><![CDATA[<p>開發時難免會需要許多邏輯，為了讓程式碼好閱讀及好整理，通常我們會整理成方法</p><p>今天會來介紹 Python 中的幾種方法</p><ul><li>實體方法 Instance Method</li><li>類別方法 Class Method</li><li>靜態方法 Static Method</li></ul><p>理解這些方法以前，</p><p>我們先來看看什麼是 「 Class 類別 」、「 Instance 實體 」</p><p>Python 為物件導向語言 (Object Oriented Programming)</p><p>也就是說，在 Python 的世界中，幾乎所有的東西都是物件，</p><p><code>物件</code> 會有 <code>狀態 (state)</code> 與 <code>行為 (behavior)</code></p><p>包括我們待會會討論到的 <code>類別</code> 與 <code>實體</code> ，在 Python 中也都是物件</p><h3 id="Class-類別"><a href="#Class-類別" class="headerlink" title="Class 類別"></a>Class 類別</h3><p>在 Python 中，Class 類別就像是模型</p><p>我們可以依照模型來製造許多的成品(就是所謂的 Instance 實體)</p><h3 id="Instance-實體"><a href="#Instance-實體" class="headerlink" title="Instance 實體"></a>Instance 實體</h3><p>從類別中產生出來的物件，會保有類別的 <code>狀態</code> 與 <code>行為</code></p><h3 id="function-方法"><a href="#function-方法" class="headerlink" title="function 方法"></a>function 方法</h3><p>在 Python 中，方法也是物件</p><p>現在我們就來看看方法的種類吧</p><h3 id="Instance-Method-實體方法"><a href="#Instance-Method-實體方法" class="headerlink" title="Instance Method 實體方法"></a>Instance Method 實體方法</h3><p>看名字就像是實體專用的方法，不過真的是這樣嗎？</p><p>在 Python 中，當實體在使用方法的時候，會將自己做為方法的引數來呼叫，我們來看看例子</p><p>當 <code>ning</code> 作為 <code>getting_old</code> 的 receiver 的時候，</p><p>會把自己作為引數來做呼叫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self, age):</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def getting_old(self):</span><br><span class="line">        self.age += 1</span><br><span class="line">      </span><br><span class="line">ning = Person(age=17)</span><br><span class="line"></span><br><span class="line">ning.getting_old() // 18</span><br></pre></td></tr></table></figure><p>這時候的 <code>getting_old</code> 會是一個 <code>bound method</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line"></span><br><span class="line">    def __init__(self, age):</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def getting_old(self):</span><br><span class="line">        self.age += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ning = Person(age = 17)</span><br><span class="line"></span><br><span class="line">print(ning.getting_old) // &lt;bound method Person.getting_old of &lt;__main__.Person object at 0x102f626c0&gt;&gt;</span><br></pre></td></tr></table></figure><p>而 <code>bound method</code> 為 <code>method object</code> 的實體</p><p>據 Python 官方手冊對於 <code>method object</code> 的解釋：</p><p>當實體在呼叫該方法時，它會將實體作為第一個引數，並進行呼叫</p><blockquote><p>the special thing about methods is that the instance object is passed as the first argument of the function.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(ning.getting_old.__class__) // &lt;class &#x27;method&#x27;&gt;</span><br></pre></td></tr></table></figure><p>那如果改成類別呢？</p><p>此時 <code>getting_old</code> 會是一個 function 物件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self, age):</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def getting_old(self):</span><br><span class="line">        self.age += 1</span><br><span class="line"></span><br><span class="line">print(Person.getting_old) // &lt;function Person.getting_old at 0x100c40e00&gt;</span><br></pre></td></tr></table></figure><p>不過這時候就會出現錯誤訊息，因為 <code>getting_old</code> 必須要有一個參數(self)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self, age):</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def getting_old(self):</span><br><span class="line">        self.age += 1</span><br><span class="line"></span><br><span class="line">print(Person.getting_old()) // TypeError: Person.getting_old() missing 1 required positional argument: &#x27;self&#x27;</span><br></pre></td></tr></table></figure><p>為什麼同樣的方法，不同的 receiver 會變成不同的物件呢？</p><p>當物件找到方法後，會透過一個叫做 <code>__get__</code> 的方法來判斷物件是 <code>類別</code> 還是 <code>實體</code> ，並且回傳 <code>method-wrapper</code> 的實體</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(ning.getting_old.__get__) // &lt;method-wrapper &#x27;__get__&#x27; of function object at 0x10498cd60&gt;</span><br><span class="line"></span><br><span class="line">print(Person.getting_old.__get__) // &lt;method-wrapper &#x27;__get__&#x27; of function object at 0x10498cd60&gt;</span><br></pre></td></tr></table></figure><p>接著我們來看一下 <code>__init__</code> 初始化樣子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(ning.getting_old.__init__) // &lt;method-wrapper &#x27;__init__&#x27; of method object at 0x100af5ec0&gt;</span><br><span class="line"></span><br><span class="line">print(Person.getting_old.__init__) // &lt;method-wrapper &#x27;__init__&#x27; of function object at 0x100af0e00&gt;</span><br></pre></td></tr></table></figure><p>在這邊我們就可以看到兩者的差異</p><p>用 ning(實體) 來存取方法，方法會被轉為 <code>method object</code>，也就是我們剛剛看到的 <code>bound method</code><br>用 Person(類別) 來存取方法，一樣會是 <code>function object</code></p><p>再複習一下 <code>bound method</code> 為方法將屬於該物件，可想像成是將方法綁在該物件上，只有該物件能做使用，並且在呼叫時，會將物件本身作為引數帶入</p><blockquote><p>A method is a function that “belongs to” an object.</p></blockquote><p>而單純的 function object，即是指沒有被綁定在物件上、不屬於任何物件的 function</p><h3 id="Class-Method-類別方法"><a href="#Class-Method-類別方法" class="headerlink" title="Class Method 類別方法"></a>Class Method 類別方法</h3><p>除了實體方法，Python 中也有類別方法，聽起來也像是專門給類別使用的</p><p>不過說穿了，類別方法也只是一般的 function object 而已</p><p>用類別來呼叫方法時，會印出預期中的結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def show_method():</span><br><span class="line">        print(&quot;This is show method&quot;)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">Person.show_method() // This is show method</span><br></pre></td></tr></table></figure><p>這時候的 <code>show_method</code> 就只是一般的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def show_method():</span><br><span class="line">        print(&quot;This is show method&quot;)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">print(Person.show_method) // &lt;function Person.show_method at 0x104e60cc0&gt;</span><br></pre></td></tr></table></figure><p>有實驗精神的我們，用 <code>__init__</code> 來看一下</p><p>的確是一般的 function object</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Person.show_method.__init__) // &lt;method-wrapper &#x27;__init__&#x27; of function object at 0x102364cc0&gt;</span><br></pre></td></tr></table></figure><p>如果換成是實體來作為 receiver 呢？</p><p>首先在 <code>__get__</code> 之後就被轉為 <code>method object</code>（也就是 <code>bound method</code>）</p><p>將方法綁在 ning 身上了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ning = Person(age=17)</span><br><span class="line">print(ning.show_method.__init__) // &lt;method-wrapper &#x27;__init__&#x27; of method object at 0x10040a040&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def show_method():</span><br><span class="line">        print(&quot;This is show method&quot;)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">ning = Person(age=17)</span><br><span class="line">print(ning.show_method) // &lt;bound method Person.show_method of &lt;__main__.Person object at 0x10433a690&gt;&gt;</span><br></pre></td></tr></table></figure><p>但由於 <code>bound method</code> 是需要將物件本身當作引數傳進 function 並呼叫，</p><p>類別方法並沒有任何參數，因此引發錯誤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def show_method():</span><br><span class="line">        print(&quot;This is show method&quot;)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">ning = Person(age=17)</span><br><span class="line">ning.show_method() // TypeError: Person.show_method() takes 0 positional arguments but 1 was given</span><br></pre></td></tr></table></figure><h3 id="實體方法與類別方法"><a href="#實體方法與類別方法" class="headerlink" title="實體方法與類別方法"></a>實體方法與類別方法</h3><p>其實實體方法與類別方法，本質上都是單純的 function，甚至跟有沒有參數無關</p><p>差別在於存取及呼叫的時候：</p><p>如果 receiver 是實體，就會轉成 <code>method object</code> ，將方法綁定在物件上，並將物件作為引數帶入呼叫</p><p>如果 receiver 是類別，依舊為一般的 <code>function object</code></p><p>所以並沒有實體不能使用類別方法，類別不能使用實體方法的規則，只是因為在呼叫時期的動作不同，就會引發錯誤</p><h3 id="classmethod"><a href="#classmethod" class="headerlink" title="@classmethod"></a>@classmethod</h3><p>由於版本相容性的問題 Python3 推出了一個裝飾器 <code>@classmethod</code> (忘記裝飾器可參考 <a href="https://ninglab.com/Python-function-decorator/">PYTHON - 函式裝飾器 FUNCTION DECORATOR</a></p><p>必須要使用 <code>cls</code> 作為參數帶入，這時候不管是實體還是類別，</p><p>存取的時候都變成了 <code>bound method</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def show_method(cls):</span><br><span class="line">        print(&quot;This is show method&quot;)</span><br><span class="line">        </span><br><span class="line">print(ning.show_method) // &lt;bound method Person.show_method of &lt;class &#x27;__main__.Person&#x27;&gt;&gt;</span><br><span class="line">print(Person.show_method) // &lt;bound method Person.show_method of &lt;class &#x27;__main__.Person&#x27;&gt;&gt;</span><br></pre></td></tr></table></figure><p>而實體跟類別都可以做使用</p><blockquote><p>A class method can be called either on the class (such as C.f()) or on an instance (such as C().f()).</p></blockquote><p>當實體呼叫的時候，實體會被忽略，實際上是該實體的類別在呼叫，</p><p>所以實體呼叫時也不會有錯誤訊息，因為會去找該實體的類別</p><h3 id="Static-Method-靜態方法"><a href="#Static-Method-靜態方法" class="headerlink" title="Static Method 靜態方法"></a>Static Method 靜態方法</h3><p>靜態方法不需要傳遞 類別 或者 實體 做為參數進去 function</p><p>通常沒有涉及到更改 類別 或 實體 的 attribute ，就可以用靜態方法來做</p><p>例如今天要計算傳進來的參數 * 100 等於多少，就很適合用靜態方法</p><p>(當然要傳 類別 或 實體 的 attribute 進去也可以，不過比起靜態方法，實體方法或類別方法可能更適合)</p><p>Python3 有提供靜態方法的裝飾器 <code>@staticmethod</code></p><p>裝上去即可使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def show_method(yoyo):</span><br><span class="line">        print(yoyo*100)</span><br><span class="line">        </span><br><span class="line">ning = Person(age=17)</span><br><span class="line">        </span><br><span class="line">Person.show_method(10) // 1000</span><br><span class="line">ning.show_method(ning.age) // 1700</span><br></pre></td></tr></table></figure><p>參考資料：</p><p><a href="https://docs.python.org/3/tutorial/classes.html">https://docs.python.org/3/tutorial/classes.html</a></p><p><a href="https://realpython.com/instance-class-and-static-methods-demystified/">https://realpython.com/instance-class-and-static-methods-demystified/</a></p>]]></content>
    
    
    <summary type="html">Python 中的實體方法跟類別方法差異在哪裡？靜態方法又是什麼？</summary>
    
    
    
    <category term="Python" scheme="http://ninglab.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Django - 基礎 models 概念與關聯</title>
    <link href="http://ninglab.com/Django-models-1/"/>
    <id>http://ninglab.com/Django-models-1/</id>
    <published>2024-05-19T10:24:05.000Z</published>
    <updated>2024-05-19T10:42:12.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django-Models"><a href="#Django-Models" class="headerlink" title="Django - Models"></a>Django - Models</h1><p>Django 所採用的模式是 MTV 模式</p><p>上週介紹的 Views 文章有提到 MTV 模式，我們再來複習一下</p><p>使用者瀏覽網頁時，伺服器的運作流程如下：</p><p><img src="https://imgur.com/wg4bxVE.jpg" alt="MTV"></p><p>urls.py 會將 request 傳送至 View</p><p>View 收到 request，處理過程中需要資料庫的資料時，就會向 Model 要資料</p><p>Model 收到 View 來的指令，將處理好的資料給 View (* Model 不是代表資料庫，而是 負責與資料庫溝通 的一個 Layer )</p><p>View 收到資料後，將資料做最後的處理</p><p>View 拿 Template 的東西來進行 render，最後由 View 回應給使用者</p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>我們這週要來介紹的是 Model</p><p>當我們需要處理資料時，就會需要 Model</p><p>Model 並不是只資料庫，而是跟資料庫溝通的一層 Layer</p><p>我們先來了解什麼是 <code>ORM</code></p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>Django 採用 ORM 來處理資料，ORM 全名為 <code>Object Relational Mapping</code> ，</p><p>原本我們要使用 SQL 語法 跟資料庫溝通</p><p>不過 ORM 讓我們可以用 <code>物件</code> 的方式來處理資料</p><p>假設我想看某個 table 的所有資料</p><p>我必須要用 SQL 語法來查詢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name;</span><br></pre></td></tr></table></figure><p>但如果是用 Django 的 ORM 語法呢？會簡單易懂許多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.objects.all()</span><br></pre></td></tr></table></figure><p>了解了 ORM 語法後，我們可以先來看一下該怎麼定義 table 以及 column</p><h2 id="models-py"><a href="#models-py" class="headerlink" title="models.py"></a>models.py</h2><p>我們會將要定義的 table 以及 column 放在 models.py 這個檔案之中</p><h3 id="fields"><a href="#fields" class="headerlink" title="fields"></a>fields</h3><p>在 Django 的手冊中指出，每個 model 都是 class，因此可以繼承 django.db.models.Model 的特性</p><blockquote><p>Each model is a Python class that subclasses django.db.models.Model</p></blockquote><p>所以第一件事就是用 <code>class</code> 的方式定義 <code>table</code></p><p>並在該 class 中定義屬性，這些屬性代表 <code>table</code> 中的 <code>column</code> ，在 Django 稱作為 field</p><blockquote><p>Each field is specified as a class attribute, and each attribute maps to a database column.</p></blockquote><p>我們要先 import <code>models</code>，讓 class 去繼承 models 中的 Model</p><p>接著定義 table 的名稱以及屬性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class User(models.Model):</span><br><span class="line">    name = models.CharField(max_length=20, default=&quot;&quot;)</span><br></pre></td></tr></table></figure><p>理解基本的 table 以及 column 定義後，我們可以來點關聯！</p><h3 id="one-to-one"><a href="#one-to-one" class="headerlink" title="one to one"></a>one to one</h3><p>有些資料會有一對一的關聯，舉例來說</p><p>除了基本 User 資料，需要有另一個 Model 來存個人資訊，像是 地址 &#x2F; mail &#x2F; 電話等等</p><p>這時候 User 與個人資料 table 就會有一對一的關聯</p><p>該怎麼做呢？</p><h4 id="ForeignKey"><a href="#ForeignKey" class="headerlink" title="ForeignKey"></a>ForeignKey</h4><p>當我們知道一個 User 會有一個 Profile 之後，</p><p>就可以用 <code>關係</code> 來想看看 <code>ForeignKey</code> 設定該放在哪裡</p><p>通常我們會將 Foreign Key 放置在「屬於」的 Model 中</p><p>以剛剛的例子來說，是 Profile 會 <code>屬於</code> 一個 User</p><p>所以我們會將 <code>ForeignKey</code> 放在 <code>Profile</code> 該 table 中</p><p>ForeignKey 就像是一條線索， Profile 會透過該線索，去找到 User</p><p><img src="https://imgur.com/6CSSwpF.jpg" alt="one to one"></p><p>接著我們就來把它轉變成程式碼吧！</p><p>在 ForeignKey 中有幾個必填的參數</p><blockquote><p>class ForeignKey(to, on_delete, **options)</p></blockquote><p>第一個參數是 ForeignKey 會指向哪個 model</p><p>第二個參數 on_delete 意思是當 <code>關聯 model</code> 的資料被刪除時，要做什麼事，這邊我們設定成 models.CASCADE ，代表當 User 被刪除時，跟該筆有關的 Profile 都會被刪除</p><p>第三個參數是為了一對一的關聯而設定的，我們希望一筆 User 只對應一筆 Profile ，對於 Profile 來說，每一個 User 的 id 都是獨特的，不可重複</p><p>(如果沒有設定這個參數，那就會變成 User 可以有多筆 Profile 囉)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class User(models.Model):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Profile(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    user = models.ForeignKey(User, on_delete=models.CASCADE, unique=True)</span><br></pre></td></tr></table></figure><h4 id="OneToOneField"><a href="#OneToOneField" class="headerlink" title="OneToOneField"></a>OneToOneField</h4><p>Django 也有提供更明確的一對一關聯方法，</p><p>也就是 OneToOneField</p><p>這個方法會會直接在 Profile 中增加一個欄位，存放 Foreign Key (也就是 User 的 id )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class User(models.Model):</span><br><span class="line">    name = models.CharField(max_length=10)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Profile(models.Model):</span><br><span class="line">    email = models.CharField(max_length=10, default=&quot;&quot;)</span><br><span class="line">    address = models.CharField(max_length=50, default=&quot;&quot;)</span><br><span class="line">    phone = models.CharField(max_length=10, default=&quot;&quot;)</span><br><span class="line">    user = models.OneToOneField(User, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><p>上述兩種方法都可以建立一對一的關聯，</p><p>相較於 <code>ForeignKey</code> 的方式，<code>OneToOneField</code> 在程式碼中會顯得更易讀明確</p><h3 id="many-to-one"><a href="#many-to-one" class="headerlink" title="many to one"></a>many to one</h3><p>再來就是稍微複雜的關聯，多對一，</p><p>舉例來說，今天一個 User 會有多筆 Order</p><p>但一筆 Order 只能對應一個 User</p><p>這時候就會形成 <code>多對一</code> 的關聯</p><p>我們來看一下該怎麼設定</p><h4 id="ForeignKey-1"><a href="#ForeignKey-1" class="headerlink" title="ForeignKey"></a>ForeignKey</h4><p>就像剛剛舉例的，我們會將 <code>Foreign Key</code> 放在 「屬於」 的 table </p><p>這次的例子是 多筆 Order 會屬於一個 User</p><p>所以我們會將 <code>ForeignKey</code> 該設定放在 Order 中</p><p>我們直接用圖片來理解比較快</p><p><img src="https://imgur.com/NR6Jwsv.jpg" alt="many to one"></p><p>理解了多對一的關係後，我們就可以來轉變成程式碼了</p><p>跟剛剛的一對一不同，這時每個 Order 的 User 是可以重複的，所以我們不需要加上 <code>unique=True</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class User(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">class Order(models.Model):</span><br><span class="line">    user = models.ForeignKey(User, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><h3 id="many-to-many"><a href="#many-to-many" class="headerlink" title="many to many"></a>many to many</h3><p>再來就會更複雜一點，也就是多對多的關聯</p><p>舉例來說，使用者與群組的關聯，</p><p>一個使用者可以參加多個群組，</p><p>而一個群組可以擁有多個使用者，</p><p>這時候就會形成多對多的關聯</p><p><img src="https://imgur.com/NWvEUxd.jpg" alt="many to many"></p><h4 id="ManyToManyField"><a href="#ManyToManyField" class="headerlink" title="ManyToManyField"></a>ManyToManyField</h4><p>Django 提供了我們 ManyToManyField 的方法</p><p>這次的關係是 一個使用者可以 <code>屬於</code> 多個群組 且 一個群組可以 <code>屬於</code> 多個使用者</p><p>不過通常多對多的關係，都會用第三方表格來存放雙方的關聯</p><p>所以 <code>ForeignKey</code> 會放在第三方表格中</p><p>而 User 及 Group 則是要設定 <code>ManyToManyField</code> 以及 through 參數，</p><p>當你需要用 User 去查詢 Group 的時候就會比較方便，不需要透過第三方表格</p><ul><li>屬性的定義 是要用複數，不然會跑出提醒你要改名的錯誤訊息</li><li>User 在建立的時候，Group 還不存在，因此要用字串來取代</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class User(models.Model):</span><br><span class="line">  groups = models.ManyToManyField(&#x27;Group&#x27;, through=&quot;UserGroup&quot;)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">class Group(models.Model):</span><br><span class="line">  users = models.ManyToManyField(User, through=&quot;UserGroup&quot;)</span><br><span class="line">  </span><br><span class="line">class UserGroup(models.Model):</span><br><span class="line">  user = models.ForeignKey(User, on_delete=models.CASCADE)</span><br><span class="line">  group = models.ForeignKey(Group, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><p>雖然多對多的關係可以在第三方表格用 <code>ForeignKey</code> 來設定關聯，</p><p>但如果沒有透過 <code>ManyToManyField</code></p><p>在查找資料的時候就都得透過第三方表格，其實蠻不方便的</p><p>所以還是要設定 <code>ManyToManyField</code> 以及 <code>through</code> 參數唷</p><p>基本的關聯差不多都介紹完了，接下來就剩怎麼將定義變成資料庫中的 table 以及 column</p><h3 id="migration"><a href="#migration" class="headerlink" title="migration"></a>migration</h3><p>當我們將 table 及 column 都設定好之後，就可以來做 migration 啦</p><p>migration 是什麼呢？</p><p>我們可以把它想像成是 Database 的歷史紀錄</p><p>有任何的更動都會被記錄在 migration 中</p><p>在 Django 中，我們只要下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure><p>就會依照更動來做出新的 migration 囉</p><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><p>當 migration 做完，我們就該來改變資料庫的 table 以及 column</p><p>這時候就需要下 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>資料庫這時候就會依據設定改變了</p><h4 id="狀況題：如果-migrate-之後，又要做更動該怎麼辦？"><a href="#狀況題：如果-migrate-之後，又要做更動該怎麼辦？" class="headerlink" title="狀況題：如果 migrate 之後，又要做更動該怎麼辦？"></a>狀況題：如果 migrate 之後，又要做更動該怎麼辦？</h4><p>只要動到 models 這個檔案，再重新做一次 makemigrations 再 migrate 就可以了</p><h4 id="狀況題：如果需要更改-migration-的時候該怎麼辦"><a href="#狀況題：如果需要更改-migration-的時候該怎麼辦" class="headerlink" title="狀況題：如果需要更改 migration 的時候該怎麼辦"></a>狀況題：如果需要更改 migration 的時候該怎麼辦</h4><p>在 Django 中，有可以讓我們 rollback 的指令</p><p>什麼是 rollback 呢？可以把它想像成是鍵盤的 ctrl + z 復原鍵</p><p>我們要將 migration 復原可以下該指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate YOUR-APP-NAME YOUR-ROLLBACK-MIGRATION-NUMBER</span><br></pre></td></tr></table></figure><p>這時候就可以進行復原</p><p>以上是基礎的 Django model 使用介紹</p><p>如果還有狀況題想要提出討論，歡迎在底下留言，會傳送到我的 github 作為 issue 通知我，屆時可以一起討論</p><p>如果有幫助的話也歡迎按讚 ヾ(<em>´∀ ˋ</em>)ﾉ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Django-Models&quot;&gt;&lt;a href=&quot;#Django-Models&quot; class=&quot;headerlink&quot; title=&quot;Django - Models&quot;&gt;&lt;/a&gt;Django - Models&lt;/h1&gt;&lt;p&gt;Django 所採用的模式是 MTV 模式&lt;</summary>
      
    
    
    
    <category term="Django" scheme="http://ninglab.com/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>Django - views 的職責與方式</title>
    <link href="http://ninglab.com/Django-views/"/>
    <id>http://ninglab.com/Django-views/</id>
    <published>2024-05-12T09:58:34.000Z</published>
    <updated>2024-05-12T13:34:39.508Z</updated>
    
    <content type="html"><![CDATA[<p>提到 Views 之前，我們先來認識 MTV 架構</p><p>Django 所採用的模式是 MTV 模式</p><p>使用者瀏覽網頁時，伺服器的運作流程如下：</p><ol><li><p>urls.py 會將 request 傳送至 View</p></li><li><p>View 收到 request，處理過程中需要資料庫的資料時，就會向 Model 要資料</p></li><li><p>Model 收到 View 來的指令，將處理好的資料給 View (* Model 不是代表資料庫，而是 <code>負責與資料庫溝通</code> 的一個 Layer )</p></li><li><p>View 收到資料後，將資料做最後的處理</p></li><li><p>View 拿 Template 的東西來進行 render，最後由 View 回應給使用者</p></li></ol><p>對於 Django 的 MTV 架構有一點概念後，我們就來看看 <code>views</code> 吧！</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>我們需要做一個路徑來給 views ，好讓 Django 收到需求之後，知道該去哪裡</p><p>來看看下方例子：</p><p>我們在 url 定義了一個路徑 <code>users/</code> </p><p>這表示，當使用者進入到該路徑時，會去找 views 的 index 方法</p><p>url 不熟的話歡迎參閱 <a href="https://ninglab.com/Django-urls-1/">Django - URLS 的那些基礎用法</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># user/url.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&#x27;, views.index, name=&quot;index&quot;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在這之前，我們要先去 views 中建立名為 <code>index</code> 的方法，讓 request 過來的時候可以提供需要的資料</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># user/views.py</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    users = User.objects.all()    </span><br><span class="line">    return render(request, &quot;index.html&quot;, &#123;&quot;users&quot;: users&#125;)</span><br></pre></td></tr></table></figure><p>對於 <code>templates</code> 到 <code>views</code> 有概念後，我們就可以再深入來看看 <code>views</code></p><h3 id="views-的職責-Request-and-Response"><a href="#views-的職責-Request-and-Response" class="headerlink" title="views 的職責 - Request and Response"></a>views 的職責 - Request and Response</h3><p>views 是一種 Function ，負責接受 request ，並且回傳 response</p><p>回傳的格式可以是 html &#x2F; xml 或者是 image </p><p>頁面收到 request 時， Django 會將建立一個 <code>HttpRequest 物件</code>，會包含 request 中的 <code>metadata 資料</code></p><p>HttpRequest 會作為<code>第一個參數</code>傳遞至對應的 views 中</p><p>剛剛提到的 <code>index</code> 例子</p><p>該引數的 request 就是 HttpRequest 物件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># user/views.py</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    users = User.objects.all()    </span><br><span class="line">    return render(request, &quot;index.html&quot;, &#123;&quot;users&quot;: users&#125;)</span><br></pre></td></tr></table></figure><p>當 views 處理好資料後，<code>必須</code> 要傳遞一個 HttpResponse 物件回去</p><p>以 <code>index</code> 例子來說，我們是回傳一個 render 方法回去</p><p>讓我們來看一下 render 這個方法</p><p>他會將參數變成一包 <code>HttpResponse 物件</code>，並且回傳</p><blockquote><p>Combines a given template with a given context dictionary and returns an HttpResponse object with that rendered text.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># user/views.py</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    users = User.objects.all()    </span><br><span class="line">    return render(request, &quot;index.html&quot;, &#123;&quot;users&quot;: users&#125;)</span><br></pre></td></tr></table></figure><p>了解 views 的職責後，我們就來看一下方式</p><h2 id="views"><a href="#views" class="headerlink" title="views"></a>views</h2><p>在 Django 中， views 可以用兩種方式來做</p><p>第一種是 <code>Function-based views</code> </p><p>第二種是 <code>Class-based views</code> </p><p>在專案中，你可以同時使用 Function-based views 或者是 Class-based views </p><p>取決於程式碼以及需求</p><h2 id="Function-based-views"><a href="#Function-based-views" class="headerlink" title="Function-based views"></a>Function-based views</h2><p>Django 預設的 views 方式，也就是 <code>一般的 Function</code>，相較於 <code>Class-based views</code> 更簡單好寫且好閱讀</p><p>也因為簡單，通常會應用在靜態頁面中</p><p>以上方程式碼的例子來說，就是一種 <code>Function-based views</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># user/views.py</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    users = User.objects.all()    </span><br><span class="line">    return render(request, &quot;index.html&quot;, &#123;&quot;users&quot;: users&#125;)</span><br></pre></td></tr></table></figure><h2 id="Class-based-views"><a href="#Class-based-views" class="headerlink" title="Class-based views"></a>Class-based views</h2><p>隨著專案日益龐大，如果這時候還是使用 <code>Function-based views</code> 會有不好擴充，以及重複程式碼的缺點</p><p><code>Class-based views</code> 就是為了解決這個問題而產生的</p><p>就以 edit 頁面來看好了，當我們使用 <code>Function-based views</code> 的話會像這樣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def edit(request, id=None):</span><br><span class="line">    user = get_object_or_404(User, id=id)</span><br><span class="line"></span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        form = UserForm(request.POST)</span><br><span class="line"></span><br><span class="line">        if form.is_valid():</span><br><span class="line">            user.name = form.cleaned_data[&quot;name&quot;]</span><br><span class="line">            user.age = form.cleaned_data[&quot;age&quot;]</span><br><span class="line">            user.email = form.cleaned_data[&quot;email&quot;]</span><br><span class="line">            user.address = form.cleaned_data[&quot;address&quot;]</span><br><span class="line">            user.phone = form.cleaned_data[&quot;phone&quot;]</span><br><span class="line"></span><br><span class="line">            user.save()</span><br><span class="line"></span><br><span class="line">            return redirect(&quot;show&quot;, id=id)</span><br><span class="line">    else:</span><br><span class="line">        form = UserForm(user.__dict__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return render(request, &quot;edit.html&quot;, &#123;&quot;form&quot;: form, &quot;user&quot;: user&#125;)</span><br></pre></td></tr></table></figure><p>但如果用 <code>CBV ( Class-based views )</code> 呢？</p><p>views 就會變成這樣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class UserUpdateView(UpdateView):</span><br><span class="line">    model = User</span><br><span class="line">    fields = [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;email&#x27;, &#x27;address&#x27;, &#x27;phone&#x27;]</span><br><span class="line">    template_name = &#x27;edit.html&#x27;</span><br><span class="line"></span><br><span class="line">    def get_object(self, queryset=None):</span><br><span class="line">        id = self.kwargs.get(&#x27;id&#x27;)</span><br><span class="line">        return User.objects.get(id=id)</span><br></pre></td></tr></table></figure><p>這時候我們需要去改變 <code>urls.py</code> 中的設定</p><p>會用到 UserUpdateView 的 <code>as_view 類別方法</code> 來呼叫 UserUpdateView</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line">from .views import (UserUpdateView)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&lt;int:id&gt;/edit/&#x27;, UserUpdateView.as_view(), name=&quot;edit&quot;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>程式碼變得非常乾淨簡潔，如果需要哪些設定就再加上去就好了</p><h3 id="Django-中的-CBV"><a href="#Django-中的-CBV" class="headerlink" title="Django 中的 CBV"></a>Django 中的 CBV</h3><p>Django 有提供很多 CBV</p><p>以下就用 CRUD 來舉例</p><h4 id="CreateView"><a href="#CreateView" class="headerlink" title="CreateView"></a>CreateView</h4><p>會產生一個新建資料的 Form 表單</p><p>我們用一般的 <code>Function-based views</code> 會這樣寫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def new(request):</span><br><span class="line">    form = UserForm()</span><br><span class="line">    return render(request, &quot;new.html&quot;, &#123;&quot;form&quot;: form&#125;)</span><br></pre></td></tr></table></figure><p>但改成 <code>CBV</code> 就會變這樣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class UserCreateView(CreateView):</span><br><span class="line">    model = User</span><br><span class="line">    fields = [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;email&#x27;, &#x27;address&#x27;, &#x27;phone&#x27;]</span><br><span class="line">    template_name = &#x27;new.html&#x27;</span><br><span class="line">    success_url = &#x27;index&#x27;</span><br></pre></td></tr></table></figure><p>個人覺得原本的 <code>Function-based views</code> 已經蠻簡潔了，所以也不一定要改成 <code>Class based views</code> 的方式</p><ul><li><code>model</code> 是指要 create 哪個 model 的資料</li><li><code>fields</code> 是只有哪些欄位需要填寫</li><li><code>template_name</code> 是要渲染在哪個 template 中</li><li><code>success_url</code> 是讓你可以設定成功會導去的路徑，但如果在 model 有設定 <code>get_absolute_url() </code> 就不需要再設定這個， Django 會直接去抓 <code>get_absolute_url() </code> 的設定</li></ul><h4 id="UpdateView"><a href="#UpdateView" class="headerlink" title="UpdateView"></a>UpdateView</h4><p>會渲染已有資料的表單，前提是要提供參數去找出資料</p><p>使用 <code>Function-based views</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def edit(request, id=None):</span><br><span class="line">    user = get_object_or_404(User, id=id)</span><br><span class="line"></span><br><span class="line">    if request.method == &#x27;POST&#x27;:</span><br><span class="line">        form = UserForm(request.POST)</span><br><span class="line"></span><br><span class="line">        if form.is_valid():</span><br><span class="line">            user.name = form.cleaned_data[&quot;name&quot;]</span><br><span class="line">            user.age = form.cleaned_data[&quot;age&quot;]</span><br><span class="line">            user.email = form.cleaned_data[&quot;email&quot;]</span><br><span class="line">            user.address = form.cleaned_data[&quot;address&quot;]</span><br><span class="line">            user.phone = form.cleaned_data[&quot;phone&quot;]</span><br><span class="line"></span><br><span class="line">            user.save()</span><br><span class="line"></span><br><span class="line">            return redirect(&quot;show&quot;, id=id)</span><br><span class="line">    else:</span><br><span class="line">        form = UserForm(user.__dict__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return render(request, &quot;edit.html&quot;, &#123;&quot;form&quot;: form, &quot;user&quot;: user&#125;)</span><br></pre></td></tr></table></figure><p>使用 <code>CBV</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class UserUpdateView(UpdateView):</span><br><span class="line">    model = User</span><br><span class="line">    fields = [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;email&#x27;, &#x27;address&#x27;, &#x27;phone&#x27;]</span><br><span class="line">    template_name = &#x27;edit.html&#x27;</span><br><span class="line">    success_url = reverse_lazy(&#x27;index&#x27;)</span><br><span class="line"></span><br><span class="line">    def get_object(self):</span><br><span class="line">        id = self.kwargs.get(&#x27;id&#x27;)</span><br><span class="line">        return User.objects.get(id=id)</span><br></pre></td></tr></table></figure><p>使用 UpdateView 是需要傳遞 <code>pk</code> &#x2F; <code>slug</code> 去讓他找出資料</p><p>不過 User 剛好沒有這兩個欄位，所以就用了 <code>get_object</code> 來找資料</p><h4 id="DeleteView"><a href="#DeleteView" class="headerlink" title="DeleteView"></a>DeleteView</h4><p>只要 request 是 POST ，且資料存在的話，就會刪除</p><p>用 <code>Function-based views</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def delete(request, id=None):</span><br><span class="line">    if request.method == &quot;POST&quot;:</span><br><span class="line">        user = get_object_or_404(User, id=id)</span><br><span class="line"></span><br><span class="line">        user.delete()</span><br><span class="line">        return redirect(&quot;index&quot;)</span><br><span class="line">    else:</span><br><span class="line">        return HttpResponseNotAllowed([&quot;POST&quot;])</span><br></pre></td></tr></table></figure><p>使用 <code>CBV</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class UserDeleteView(DeleteView):</span><br><span class="line">    model = User</span><br><span class="line">    success_url = reverse_lazy(&quot;index&quot;)</span><br><span class="line"></span><br><span class="line">    def get_object(self):</span><br><span class="line">        id = self.kwargs.get(&#x27;id&#x27;)</span><br><span class="line">        return User.objects.get(id=id)</span><br></pre></td></tr></table></figure><p>Django 的 <code>Function-based views</code> 以及 <code>Class-based views</code> 各有擁護者，</p><p>且 <code>Class-based views</code> 並不是用來取代 <code>Function-based views</code> 的，他們各有所長</p><p>至於要使用哪個方式，我個人認為還是要照需求以及團隊的 coding style 來決定</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;提到 Views 之前，我們先來認識 MTV 架構&lt;/p&gt;
&lt;p&gt;Django 所採用的模式是 MTV 模式&lt;/p&gt;
&lt;p&gt;使用者瀏覽網頁時，伺服器的運作流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;urls.py 會將 request 傳送至 View&lt;/p&gt;
&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Django" scheme="http://ninglab.com/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>Django - urls 的那些基礎用法</title>
    <link href="http://ninglab.com/Django-urls-1/"/>
    <id>http://ninglab.com/Django-urls-1/</id>
    <published>2024-04-28T13:24:45.000Z</published>
    <updated>2024-05-12T11:19:02.141Z</updated>
    
    <content type="html"><![CDATA[<p>當使用者點選網址進入網站時，會發送 <code>request</code> 給伺服器，<br>不過伺服器怎麼知道他要做什麼，並且需要什麼資料呢？</p><p>今天要來介紹 Django 中的 urls </p><p><img src="https://imgur.com/L01upJS.jpg" alt="Ning-draw (30)"></p><h2 id="ROOT-URLCONF"><a href="#ROOT-URLCONF" class="headerlink" title="ROOT_URLCONF"></a>ROOT_URLCONF</h2><p>當使用者進入到網域中的其中一個頁面時，會發送 request 給 server</p><p>Django 收到時，會先去 <code>settings.py</code> 找 <code>ROOT_URLCONF</code></p><p>看看 URL 的設定放在哪個檔案中</p><p>可以將 <code>ROOT_URLCONF</code> 想像成百貨公司的樓層介紹，</p><p>當我們想要吃麥當勞的時候，該去哪層樓的哪個櫃位</p><p>假設今天要做一個電商網站，那麼就可以將 <code>urls.py</code> 在最上層的 module 中整合</p><p>以下方例子來說，我就會將 <code>ROOT_URLCONF</code> 設定為 <code>cake_shop.urls</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># project/cake_shop/settings.py</span><br><span class="line"></span><br><span class="line">ROOT_URLCONF = &#x27;cake_shop.urls&#x27;</span><br></pre></td></tr></table></figure><p>每個模組會有自己的 <code>urls</code> ，但個別模組的 urls.py 最後都會 include 到 <code>cake_shop.urls</code> 來彙整</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">├── cake_shop</span><br><span class="line">│  ├── __init__.py</span><br><span class="line">│  ├── asgi.py</span><br><span class="line">│  ├── settings.py</span><br><span class="line">│  ├── urls.py</span><br><span class="line">│  └── wsgi.py</span><br><span class="line">├── member</span><br><span class="line">│  └── migration</span><br><span class="line">│  ├── __init__.py</span><br><span class="line">│  ├── app.py</span><br><span class="line">│  ├── admin.py</span><br><span class="line">│  ├── models.py</span><br><span class="line">│  ├── tests.py</span><br><span class="line">│  ├── urls.py</span><br><span class="line">│  └── views.py</span><br><span class="line">└── manage.py</span><br></pre></td></tr></table></figure><p>Django 知道該去哪裡找 <code>urls</code> 後，就會進到該 <code>urls.py</code> 中</p><h2 id="urlpatterns"><a href="#urlpatterns" class="headerlink" title="urlpatterns"></a>urlpatterns</h2><p><code>urls.py</code> 中會有個變數叫做 <code>urlpatterns</code> ，</p><p>在這個變數中，會指定一系列的 <code>path</code> 給他，</p><p>而這一系列的 <code>path</code> 會是 urls 模組底下的 <code>path 方法</code> 或者 <code>re_path 方法</code> 的實體</p><blockquote><p>This should be a sequence of django.urls.path() and&#x2F;or django.urls.re_path() instances</p></blockquote><p>Django 已經先幫我們做出一個管理員的路徑了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;admin/&#x27;, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>讓我們來看一下 <code>path</code> 該怎麼寫吧</p><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>Django 官方文件對於 path 方法規範如下：</p><blockquote><p>path(route, view, kwargs&#x3D;None, name&#x3D;None)</p></blockquote><p>讓我們來看一下參數：</p><p><code>route</code> 表示要顯示在網址上的路徑，前面不需要加上 <code>/</code> 因為原本的 URL 就會有了<br><code>view</code> 表示這個路徑要去找 <code>views.py</code> 中的哪個方法<br><code>kwargs</code> 指的是 <code>keyword argument</code> 也就是需要給他明確的 <code>keyword</code> 跟 <code>value</code><br><code>name</code> 方便我們用更簡潔且易讀的方式代表 URL</p><p>假設我們今天有個頁面需要顯示所有使用者的，這時候我就先會設定他的路徑</p><p>希望該頁面顯示的網址是 <code>https://網域/users</code><br>並且會去找 views 中的 index 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&#x27;, views.index),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Path-Converter"><a href="#Path-Converter" class="headerlink" title="Path Converter"></a>Path Converter</h3><p>如果今天是要顯示該使用者的基本資料畫面呢？也就是俗稱的 <code>show</code> 頁面</p><p><code>path</code> 使用 <code>&lt;&gt;</code> 來捕捉裡面的參數，並會當作 <code>keyword argument</code> 傳入 views 中，所以我們就可以這樣寫：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&#x27;, views.index),</span><br><span class="line">    path(&#x27;users/&lt;id&gt;/&#x27;, views.show),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Path Converter 預設的型態是字串，不過還有支援 <code>integer</code> &#x2F; <code>slug</code> &#x2F; <code>uuid</code> 甚至是完整的路徑也可以</p><p>當我們要讓參數傳進 views 中的方法，方法必需要加上 <code>positional argument</code> (<code>id</code>)，也名字必須要一樣，否則就會跑出錯誤訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># project/memeber/views.py</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">def show(request, id):</span><br><span class="line">    ...</span><br><span class="line">    return render(request, &quot;show.html&quot;)</span><br></pre></td></tr></table></figure><h4 id="integer"><a href="#integer" class="headerlink" title="integer"></a>integer</h4><p>如果型態不是字串必須要在前面加上 <code>int</code> 作為 <code>parameter</code></p><p>而傳進去的都需要叫這個名稱，以下方例子來說，參數都必須要叫 <code>height</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&lt;int:height&gt;/&#x27;, views.show),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>這時候的網址就會是 <code>https://網域/users/190/</code> </p><h4 id="slug"><a href="#slug" class="headerlink" title="slug"></a>slug</h4><p>同上，只要在前面加上 <code>slug</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&lt;slug:slug&gt;/&#x27;, views.show),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h4><p>同上，只要在前面加上 <code>uuid</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&lt;uuid:uuid&gt;/&#x27;, views.show),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="選填參數"><a href="#選填參數" class="headerlink" title="選填參數"></a>選填參數</h3><p>剛剛有提到，如果要傳參數進去，必須要在方法中也給他一個 <code>positional argument</code> </p><p>但如果有兩個路徑要同時去找同一個方法，一個路徑有傳遞參數，一個沒有傳遞參數呢？</p><p>我們可以在方法中 <code>parameter</code> 給他預設值，就算路徑沒有傳參數進來，也不會壞掉了</p><p>不過應該只會在 <code>有分頁的時候</code> <code>有搜尋的時候</code> 用到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># project/member/views.py</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">def show(request, id = None):</span><br><span class="line">    ...</span><br><span class="line">    return render(request, &quot;show.html&quot;)</span><br></pre></td></tr></table></figure><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>當我們要在最上層的 <code>cake_shop</code> urls 中引入 <code>member</code> 的路徑時，</p><p>可以直接將 <code>member.urls</code> include 進來</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># project/cake_shop/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;&#x27;, include(&quot;member.urls&quot;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>如果未來想要使用 url 這種方法，為了簡化路徑，我可以加上 <code>name</code> 關鍵字參數</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">from django.urls import path</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&#x27;, views.index, name=&quot;index&quot;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>還可以搭配 <code>reverse</code> 讓程式碼更簡潔且易讀！</p><h4 id="path-reverse"><a href="#path-reverse" class="headerlink" title="path reverse"></a>path reverse</h4><p>當加入了 <code>name</code> 這個 <code>keyword argument</code> 之後，就可以在方法中用 <code>reverse</code> 簡化路徑的寫法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># project/member/views.py</span><br><span class="line">from django.urls import reverse</span><br><span class="line">from django.http import HttpResponseRedirect</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">def show(request, id = None):</span><br><span class="line">    return HttpResponseRedirect(reverse(&quot;index&quot;))</span><br></pre></td></tr></table></figure><ul><li>如果搭配 <code>HttpResponseRedirect</code> 的話不要重新導向到自己本身的方法，不然就會造成無窮迴圈，以上述的例子來說，如果我在 index 方法導向到 index，就會無窮迴圈</li></ul><p>在 form 的話我們就可以在 url 的方法，用易讀又簡短的方式寫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;&#123;% url &#x27;index&#x27; %&#125;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h4 id="namespaces"><a href="#namespaces" class="headerlink" title="namespaces"></a>namespaces</h4><p>當專案複雜度增加，模組也可能會跟著增加，這時候可能會遇到相同路徑名稱的問題，</p><p>name 命名可能因此越來越長，這時候我們可以使用 <code>namespace</code> 來做區隔 (前提是要給 name 參數唷！)</p><p>namespace 有分成兩種</p><ol><li>application namespace</li></ol><p>每個 application 都可以有自己的 namespace ，且他們的實體前綴也會有 namespace 名稱</p><p>我們可以用 <code>app_name</code> 來設定 application namespace</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># project/member/urls.py</span><br><span class="line"></span><br><span class="line">app_name = &quot;users&quot;</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;users/&#x27;, views.index, name=&quot;index&quot;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>這時候 views 的 reverse 路徑就可以設定成 <code>users:index</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># project/member/views.py</span><br><span class="line"></span><br><span class="line">def show(request, id=None):</span><br><span class="line">    print(id)</span><br><span class="line">    return HttpResponseRedirect(reverse(&quot;users:index&quot;))</span><br></pre></td></tr></table></figure><ol start="2"><li>instance namespace</li></ol><p>實體的 namespace 在這專案中必須是要獨一無二的，如果沒有特別設定，預設就會是 application 的 namespace</p><p>namespace 會用 <code>:</code> 來區隔</p><p>如果我們在 include 的時候有指定 namespace ，這時候該路徑就會被套上 instance namespace</p><p>我們可以在 cake_shop 底下的 urls.py 設定 <code>instance namespace</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># project/cake_shop/urls.py</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;&#x27;, include(&quot;member.urls&quot;, namespace=&quot;admin&quot;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>這時候 views 的 reverse 路徑就可以設定成 <code>admin:index</code> ，我們可以指定 current_app 告訴他要去找哪個 <code>application namespace</code> 底下的 <code>instance namespace</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># project/member/views.py</span><br><span class="line"></span><br><span class="line">def show(request, id=None):</span><br><span class="line">    print(id)</span><br><span class="line">    return HttpResponseRedirect(reverse(&quot;admin:index&quot;, current_app=&quot;users&quot;))</span><br></pre></td></tr></table></figure><p><code>reverse</code> 若有指定 current_app 這個參數時，就會去找這個值的 namespace</p><p>沒有的話，就會去找 application namespace </p><p>再沒有的話，就會去找 instance namespace</p><p><img src="https://imgur.com/PUBtSuT.jpg" alt="Ning-draw (30)"></p><p>今天先介紹比較基礎的 URL 用法，下一篇我們會再介紹更深入的 URL 用法</p><p>如果喜歡這篇文章歡迎幫我點選下方的 Like</p><p>如果上述文章有任何疑慮或者指教，也歡迎留言</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;當使用者點選網址進入網站時，會發送 &lt;code&gt;request&lt;/code&gt; 給伺服器，&lt;br&gt;不過伺服器怎麼知道他要做什麼，並且需要什麼資料呢？&lt;/p&gt;
&lt;p&gt;今天要來介紹 Django 中的 urls &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgur.co</summary>
      
    
    
    
    <category term="Django" scheme="http://ninglab.com/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>Python - 函式裝飾器 function decorator</title>
    <link href="http://ninglab.com/Python-function-decorator/"/>
    <id>http://ninglab.com/Python-function-decorator/</id>
    <published>2024-04-21T15:29:34.000Z</published>
    <updated>2024-04-26T13:57:33.579Z</updated>
    
    <content type="html"><![CDATA[<p>今天想來跟大家介紹 function decorator</p><h3 id="Higher-order-function"><a href="#Higher-order-function" class="headerlink" title="Higher-order function"></a>Higher-order function</h3><p>在這之前，先介紹一下什麼叫做 <code>Higher-order function</code>，就會比較好理解 function decortor</p><p>根據維基百科的介紹，<code>Higher-order function</code> 必須至少滿足以下其中一個條件</p><ol><li>至少有一個或多個 functions 作為引數</li><li>結果要返回一個 function</li></ol><blockquote><p>In mathematics and computer science, a higher-order function (HOF) is a function that does at least one of the following:</p><ol><li>takes one or more functions as arguments (i.e. a procedural parameter, which is a parameter of a procedure that is itself a procedure),</li><li>returns a function as its result.</li></ol></blockquote><p>讓我們來看看例子吧</p><p>當我們呼叫 <code>outer_fun</code> 時，傳了一個 function 做為引數，符合了 <code>Higher-order function</code> 的第一條規範，這時我們可以說 <code>outer_fun</code> 是個 <code>Higher-order function</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(inner):</span><br><span class="line">  print(inner_fun)</span><br><span class="line"></span><br><span class="line">def inner_fun():</span><br><span class="line">  print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line"></span><br><span class="line">outer_fun(inner_fun) // &lt;function inner_fun at 0x1029eccc0&gt;</span><br></pre></td></tr></table></figure><ul><li>不過如果我們在呼叫的時候，傳進去的引數不是 <code>function</code> ，然後也沒有 <code>return function</code> (第二個定義)，<br><code>outer_fun</code> 就不能被稱作是個 <code>Higher-order function</code></li></ul><p>接著我們再稍微加工一下，在 <code>outer_fun</code> 中定義一個 function 並且 return 此 function，也就是 <code>inner_fun</code> ，這時候符合了第二點的規範，<code>outer_fun</code> 就是個 <code>Higher-order function</code> 了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun():</span><br><span class="line">  def inner_fun():</span><br><span class="line">    print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line">  </span><br><span class="line">  return inner_fun</span><br><span class="line"></span><br><span class="line">outer_fun() // inner_fun 沒有執行，所以是空的</span><br></pre></td></tr></table></figure><p>我們再來點進階的範例，我們來一步步看</p><ol><li>定義了一個 function <code>outer_fun</code></li><li>foo 被指向 <code>outer_fun</code> ，帶入 3 為引數並且執行</li><li>定義了一個 function <code>inner_fun</code></li><li>回傳 <code>inner_fun</code> 這個物件，此時 foo 是指向 <code>inner_fun</code> 這個物件</li></ol><p>這時候的 <code>outer_fun</code> 也是回傳一個 function ，符合 <code>Higher-Order function</code> 第二個定義，因此可稱為 <code>Higher-Order function</code></p><p><code>outer_fun</code> 回傳的是 <code>inner_fun</code> 這個 function 物件，</p><p>並非 <code>inner_fun</code> 的執行結果，因此在執行程式碼並不會印出任何東西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(x):</span><br><span class="line">  def inner_fun(x):</span><br><span class="line">    calculator = x + x</span><br><span class="line">    print(calculator)</span><br><span class="line"></span><br><span class="line">  return inner_fun</span><br><span class="line"></span><br><span class="line">foo = outer_fun(3)</span><br></pre></td></tr></table></figure><p>現在的 foo 指向了 <code>inner_fun</code> 這個 function 物件，</p><p>如果我們想要 <code>inner_fun</code> 執行結果的話，只要執行 foo 並且帶入參數即可</p><p>這時候的 <code>outer_fun</code> 回傳的仍然是 <code>inner_fun</code> 這個 function 物件，因此仍為 <code>Higher-Order function</code></p><ol><li>定義了一個 function <code>outer_fun</code></li><li>foo 被指向 <code>outer_fun</code> ，帶入 3 為引數並且執行</li><li>定義了一個 function <code>inner_fun</code></li><li>回傳 <code>inner_fun</code> 這個物件，此時 foo 是指向 <code>inner_fun</code> 這個物件</li><li>foo 執行，也就是 <code>inner_fun</code> 執行，帶入 3 作為引數並執行</li><li>進入 <code>inner_fun</code></li><li>計算 引數相加 <code>x + x</code> ，算出結果為 3 ，並將 calculator 指向該結果</li><li>印出 calculator</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(x):</span><br><span class="line">  def inner_fun(x):</span><br><span class="line">    calculator = x + x</span><br><span class="line">    print(calculator)</span><br><span class="line"></span><br><span class="line">  return inner_fun</span><br><span class="line"></span><br><span class="line">foo = outer_fun(3)</span><br><span class="line"></span><br><span class="line">foo(3) // 6</span><br></pre></td></tr></table></figure><p>到這邊大家應該對於 <code>Higher-Order function</code> 多少有個概念了</p><p>再複習一下，<code>Higher-Order function</code> 需要符合以下其中一個定義</p><ol><li>至少有一個或多個 functions 作為引數</li><li>結果要返回一個 function</li></ol><p>那我們就帶著這兩個觀念，來看 <code>function decorator</code></p><h3 id="Decorator-pattern"><a href="#Decorator-pattern" class="headerlink" title="Decorator pattern"></a>Decorator pattern</h3><p><code>function decorator</code> 是一種設計模式，並不是只有存在於 Python ，其他程式語言，像是 JavaScript 或 Ruby 也會有，概念都是差不多的，只是差在於使用的頻率高不高</p><p>這個設計模式被稱作為 <code>Decorator pattern</code> </p><p>我們來看看維基百科的介紹</p><p>在物件導向程式中， <code>Decorator pattern</code> 在不影響同個類別下的其他實體，可以讓獨立的物件添加其他行為</p><blockquote><p>In object-oriented programming, the decorator pattern is a design pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other instances of the same class.</p></blockquote><p>我們來就拿第一個範例來看，為了方便了解，我會將 <code>outer_fun</code> 的程式碼改為 return inner</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(inner):</span><br><span class="line">  return inner</span><br><span class="line"></span><br><span class="line">def inner_fun():</span><br><span class="line">  print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line"></span><br><span class="line">outer_fun(inner_fun) // return inner_fun 該物件</span><br></pre></td></tr></table></figure><p>為了要拿到傳進去 outer_fun 的 function 引數的執行結果，我們將程式碼這樣改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(inner):</span><br><span class="line">  return inner()</span><br><span class="line"></span><br><span class="line">def inner_fun():</span><br><span class="line">  print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line"></span><br><span class="line">outer_fun(inner_fun) // I&#x27;m inner function</span><br></pre></td></tr></table></figure><p>這樣看起來還算蠻單純的，不過這不算是 <code>Decorator pattern</code>，這只是一般的 <code>Higher-Order function</code></p><p>來看看 GeeksforGeeks 的解釋：<br><code>Decorator</code> 可以讓你動態的在物件上增加行為，並且當被包裝起來的那個 function (這邊稱 wrapper) 在調用的時候不會改變原本的行為</p><blockquote><p>Decorator Method is a Structural Design Pattern which allows you to dynamically attach new behaviors to objects without changing their implementation by placing these objects inside the wrapper objects that contains the behaviors.</p></blockquote><p>如果今天專案中的許多地方都有用到 outer_fun ，改了 <code>outer_fun</code> 就可能會出錯，假設有個地方傳進去的是字串，他應該就會引發字串無法呼叫這個訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(inner):</span><br><span class="line">  return inner()</span><br><span class="line"></span><br><span class="line">def inner_fun():</span><br><span class="line">  print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line"></span><br><span class="line">outer_fun(&quot;aa&quot;) // TypeError: &#x27;str&#x27; object is not callable</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這時候我們使用 function decorator 來改剛剛的例子，只要掛上這層外衣，就可以執行</p><ul><li>Python 提供了我們 <code>@</code> 的語法糖衣，讓 Decorator pattern 寫起來更易讀</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(inner):</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@outer_fun</span><br><span class="line">def inner_fun():</span><br><span class="line">    print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line"></span><br><span class="line">inner_fun() // I&#x27;m inner function</span><br></pre></td></tr></table></figure><p>即便今天有其他地方不是傳 function 進去，也不會噴錯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def outer_fun(inner):</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@outer_fun</span><br><span class="line">def inner_fun():</span><br><span class="line">    print(&quot;I&#x27;m inner function&quot;)</span><br><span class="line"></span><br><span class="line">inner_fun() // I&#x27;m inner function</span><br><span class="line">outer_fun(3) // 不會印出任何東西，會 return inner function</span><br></pre></td></tr></table></figure><p>如果是比較複雜的狀況呢，讓我們來看看 BMI 計算機</p><p>以我自己的做法，會先處理身高，處理完再將它丟到 BMI 計算的 function 中去做計算</p><p>不過這樣在使用的時候就會傳一大堆參數，而且 <code>calculator(bmi_calculator, 50, 160) </code> 這樣寫起來並不直觀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def calculator(func, weight, height):</span><br><span class="line">    height_in_meters = height / 100</span><br><span class="line">    return func(weight, height_in_meters)</span><br><span class="line"></span><br><span class="line">def bmi_calculator(weight, height):</span><br><span class="line">    bmi = weight / (height ** 2)</span><br><span class="line">    return bmi</span><br><span class="line"></span><br><span class="line">result = calculator(bmi_calculator, 50, 160)</span><br><span class="line">print(result) // 19.531249999999996</span><br></pre></td></tr></table></figure><p>如果是使用 Decorator Pattern 的方式</p><p>一開始我會將身高丟到 calculator 中，<br>並且在 calculate_height 中處理身高，<br>最後呼叫 bmi_calculator 來得到結果 </p><p>我們可以把 calculator 想像成一間代工廠，將所有的生產線用一個工廠包裝起來</p><p>而在這個工廠中，我會各別處理元件，處理完的元件會個別組裝起來，最後送出成品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def calculator(func):</span><br><span class="line">  def calculate_height(weight, height):</span><br><span class="line">    height_in_meters = height / 100</span><br><span class="line">    </span><br><span class="line">    return func(weight, height_in_meters)</span><br><span class="line">  return calculate_height</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">def bmi_calculator(weight, height):</span><br><span class="line">    return weight / (height * height)</span><br><span class="line"></span><br><span class="line">decorated_bmi_calculator = calculator(bmi_calculator)</span><br><span class="line">result = decorated_bmi_calculator(50, 160)</span><br><span class="line">print(result) // 19.531249999999996</span><br></pre></td></tr></table></figure><p>上述的方式，我個人認為已經簡潔許多，不過在呼叫的時候還是很麻煩，而且易讀性不高</p><p>我們來 <code>@</code> 這個語法糖衣來簡化一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def calculator(func):</span><br><span class="line">    def calculate_height(weight, height):</span><br><span class="line">        def square_height(height):</span><br><span class="line">            height_in_meters = height / 100</span><br><span class="line"></span><br><span class="line">            return height_in_meters</span><br><span class="line">        return func(weight, square_height(height))</span><br><span class="line"></span><br><span class="line">    return calculate_height</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@calculator</span><br><span class="line">def bmi_calculator(weight, height):</span><br><span class="line">    return weight / (height * height)</span><br><span class="line"></span><br><span class="line">result = bmi_calculator(50, 160)</span><br><span class="line">print(result) // 19.531249999999996</span><br></pre></td></tr></table></figure><p>這樣就看起來簡潔又易讀囉！</p><h3 id="總結-何時會需要用到-function-decorator"><a href="#總結-何時會需要用到-function-decorator" class="headerlink" title="總結 - 何時會需要用到 function decorator ?"></a>總結 - 何時會需要用到 function decorator ?</h3><p>再來回顧一下 Decorator pattern 的概念</p><p><code>Decorator</code> 可以讓你動態的在物件上增加行為，並且當被包裝起來的那個 function (這邊稱 wrapper) 在調用的時候不會改變原本的行為</p><blockquote><p>Decorator Method is a Structural Design Pattern which allows you to dynamically attach new behaviors to objects without changing their implementation by placing these objects inside the wrapper objects that contains the behaviors.</p></blockquote><p>我自己會歸類成幾個時候需要使用：</p><ol><li>不想改變原本的程式碼</li></ol><p>就像剛剛的 <code>outer_fun</code> 跟 <code>inner_fun</code> 的範例</p><ol start="2"><li>有多種額外的行為需要做時</li></ol><p>以剛剛的 BMI 計算機來看，我們需要先處理身高，再進行計算，這時候就很適合用 <code>function decorator</code></p><p>不然用一般的方式需要傳入很多參數，且也不好閱讀，我們就可以用 <code>function decorator</code> 來優化</p><ol start="3"><li>使用套件的方法時</li></ol><p>也許我們在做專案的時候用不太到 <code>function decorator</code> ，不過多少應該都會用到套件，</p><p>像是在 Flask 的路徑會使用到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    return &#x27;Hello, World!&#x27;</span><br></pre></td></tr></table></figure><p>Django 的方法多少也會用到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@login_required</span><br><span class="line">def my_view(request):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>參考資料：<br><a href="https://www.geeksforgeeks.org/decorator-method-python-design-patterns/">https://www.geeksforgeeks.org/decorator-method-python-design-patterns/</a></p><p><a href="https://en.wikipedia.org/wiki/Decorator_pattern">https://en.wikipedia.org/wiki/Decorator_pattern</a></p><p><a href="https://www.sitepoint.com/javascript-decorators-what-they-are/">https://www.sitepoint.com/javascript-decorators-what-they-are/</a></p>]]></content>
    
    
    <summary type="html">Python 中的 @ 是什麼？原來 function 也需要大衣來包裝自己！</summary>
    
    
    
    <category term="Python" scheme="http://ninglab.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Ruby-用 Rack 做出自己的 Router</title>
    <link href="http://ninglab.com/Ruby-build-your-own-router-by-rack/"/>
    <id>http://ninglab.com/Ruby-build-your-own-router-by-rack/</id>
    <published>2024-04-14T08:39:15.000Z</published>
    <updated>2024-04-14T09:30:48.240Z</updated>
    
    <content type="html"><![CDATA[<p>在之前 Rebuild Rails 時有介紹到 <a href="https://ninglab.com/%E5%BE%9E0%E9%96%8B%E5%A7%8B%E5%88%BB-%E6%B7%BA%E8%AB%87-Rails-%E7%9A%84%E9%81%8B%E4%BD%9C%E9%AD%94%E6%B3%95-Day02-Rack/">Rack</a> </p><p>對於 Rack 更精準的解釋是，<br>Rack 本身是個 Ruby 與 framework 的規範，<br>符合規範的 framework 稱作是 <code>Rack application</code> ，會將程式碼處理成 Rack 規範認可的格式(也就是 object ，且可以 call) 給 WebServer</p><p>而 <code>Rack</code> 這個套件，可以透過 <code>rackup</code> 指令產生介面，讓 Rack application 運行在支援的 Server 上</p><p>當我們用純 Ruby 來寫程式，要讓用戶連上我們的服務時，要怎麼樣才可以讓程式連上 Server ？</p><p>以下來示範一段程式碼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">require &#x27;webrick&#x27;</span><br><span class="line"></span><br><span class="line"># 建立 WEBrick HTTP 伺服器</span><br><span class="line">server = WEBrick::HTTPServer.new(Port: 3000)</span><br><span class="line"></span><br><span class="line"># 設定 Route 和處理請求</span><br><span class="line">server.mount_proc &#x27;/&#x27; do |req, res|</span><br><span class="line">  res.body = &#x27;Hello! Rack Practice&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># 設定伺服器需要停止的狀況</span><br><span class="line">trap &#x27;INT&#x27; do server.shutdown end</span><br><span class="line"></span><br><span class="line"># 啟動伺服器</span><br><span class="line">server.start</span><br></pre></td></tr></table></figure><p>這樣可以讓程式碼連上 Server ，不過除了要手動一個一個寫 Route 以外，還要額外設定回應的 Body</p><p>而且，如果今天要回應的是一個 <code>html.erb</code> 檔案或者需要執行到 <code>rb</code> 檔呢？</p><p>需要寫一段程式碼去讀取檔案，或者 <code>require</code> 檔案並且渲染</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">require &#x27;webrick&#x27;</span><br><span class="line"></span><br><span class="line">server = WEBrick::HTTPServer.new(Port: 3000)</span><br><span class="line"></span><br><span class="line">server.mount_proc &#x27;/&#x27; do |req, res|</span><br><span class="line">  res.body = File.open(&#x27;public/index.html.erb&#x27;, File::RDONLY)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">trap &#x27;INT&#x27; do server.shutdown end</span><br><span class="line">server.start</span><br></pre></td></tr></table></figure><p>其實這樣是蠻麻煩的</p><p>Ruby 的框架大多遵守 Rack 的規範，讓開發者可以輕鬆處理 Route 以及 Response</p><p>為了以防大家混淆，如果講到 <code>Rack 規範</code> 我會直接使用 <code>Rack 規範</code> 來稱呼</p><p>Rack 本身支援多種 Server，舉凡開發階段使用的 <code>Puma</code> &#x2F; <code>Thin</code> ，或者是正式階段使用的 <code>NGINX</code> 都有</p><blockquote><p>This specification aims to formalize the Rack protocol.</p></blockquote><p>Rack 的官方文件提到，這些規範是為了要正式化 Rack 的 protocol</p><h3 id="用-Rack-來刻一個-Router"><a href="#用-Rack-來刻一個-Router" class="headerlink" title="用 Rack 來刻一個 Router"></a>用 Rack 來刻一個 Router</h3><p><a href="https://github.com/cacachang/rack_practice">Source Code</a></p><p>檔案的架構長這樣</p><p><code>public</code> 會放置靜態檔案<br><code>Gemfile</code> <code>Gemfile.lock</code> 會放我們該專案所需要的套件<br><code>config.ru</code> Rack 會需要解析這個檔案，去決定他該做什麼事</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rack_practice</span><br><span class="line">├── public</span><br><span class="line">│  └──index.html.erb</span><br><span class="line">├── Gemfile</span><br><span class="line">├── Gemfile.lock</span><br><span class="line">└── config.ru</span><br></pre></td></tr></table></figure><h4 id="step-1-建立一個-Rack-base-的-Application"><a href="#step-1-建立一個-Rack-base-的-Application" class="headerlink" title="step 1. 建立一個 Rack base 的 Application"></a>step 1. 建立一個 Rack base 的 Application</h4><p>剛有提到 Rack 會去解析 <code>config.ru</code> ，而我們會將設定寫在 <code>Rack::Builder.new</code> 的 block 之中，讓 Rack 知道，我們需要藉由這些設定來連接 Server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># config.ru</span><br><span class="line"></span><br><span class="line">app = Rack::Builder.new do</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li><code>Rack::Builder</code> - 用來架構一個 Rack application</li></ul><blockquote><p>Rack::Builder provides a domain-specific language (DSL) to construct Rack applications.</p></blockquote><h4 id="step-2-定義該路徑要渲染哪個檔案"><a href="#step-2-定義該路徑要渲染哪個檔案" class="headerlink" title="step 2. 定義該路徑要渲染哪個檔案"></a>step 2. 定義該路徑要渲染哪個檔案</h4><p>接著會需要設定 Route ，我們先從最簡單的 <code>/</code> 開始<br>我希望 root_path 要渲染 <code>public/index.html.erb</code> 這個靜態檔案</p><p>這時候我們可以使用 <code>Rack::Static</code> 這個方法</p><ul><li><code>Rack::Static</code> - 去攔截靜態檔案的 url 的 prefix 或者是 option 裡面的路徑參數，並且用 <code>Rack::Files</code> 來渲染畫面(root 參數指的是要在哪個資料夾找檔案)</li></ul><blockquote><p>The Rack::Static middleware intercepts requests for static files (javascript files, images, stylesheets, etc) based on the url prefixes or route mappings passed in the options, and serves them using a Rack::Files object.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># config.ru</span><br><span class="line"></span><br><span class="line">app = Rack::Builder.new do</span><br><span class="line">  map &#x27;/&#x27; do</span><br><span class="line">    use Rack::Static, urls: [&#x27;/&#x27;], root: &#x27;public&#x27;, index: &#x27;index.html.erb&#x27;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="step-3-設定頁面的-Response"><a href="#step-3-設定頁面的-Response" class="headerlink" title="step 3. 設定頁面的 Response"></a>step 3. 設定頁面的 Response</h4><p>在 run 這個 lambda 中，我們要回應 <code>status</code> &#x2F; <code>headers</code> &#x2F; <code>body</code></p><ul><li><code>Rack 規範</code>中有規定 Rack application 是個 Ruby 物件，並且要透過 call 來回應，需要以 env 為參數，並且回傳一個陣列，要包含著 <code>status</code> &#x2F; <code>headers</code> &#x2F; <code>body</code></li></ul><blockquote><p>A Rack application is a Ruby object (not a class) that responds to call. It takes exactly one argument, the environment and returns a non-frozen Array of exactly three values: The status, the headers, and the body.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># config.ru</span><br><span class="line"></span><br><span class="line">app = Rack::Builder.new do</span><br><span class="line">  map &#x27;/&#x27; do</span><br><span class="line">    use Rack::Static, urls: [&#x27;/&#x27;], root: &#x27;public&#x27;, index: &#x27;index.html.erb&#x27;</span><br><span class="line">    run lambda &#123; |_env|</span><br><span class="line">      [</span><br><span class="line">        200,</span><br><span class="line">        &#123;</span><br><span class="line">          &#x27;Content-Type&#x27;: &#x27;text/html&#x27;,</span><br><span class="line">          &#x27;Cache-Control&#x27;: &#x27;no-cache&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        File.open(&#x27;public/index.html.erb&#x27;, File::RDONLY)</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="step-4-設定-Server-停止的條件"><a href="#step-4-設定-Server-停止的條件" class="headerlink" title="step 4. 設定 Server 停止的條件"></a>step 4. 設定 Server 停止的條件</h4><p>Signal 指的是信號，簡單來說，就是收到中斷訊號時( <code>Ctrl+C</code> ) 的時候中斷 Server </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># config.ru</span><br><span class="line"></span><br><span class="line">Signal.trap &#x27;INT&#x27; do</span><br><span class="line">  Rack::Handler::WEBrick.shutdown</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="step-5-啟動-Server"><a href="#step-5-啟動-Server" class="headerlink" title="step 5. 啟動 Server"></a>step 5. 啟動 Server</h4><p>這邊我使用 <code>WEBrick</code> 作為 Server，指定 Port 3000 給他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># config.ru</span><br><span class="line"></span><br><span class="line">Rack::Handler::WEBrick.run app, Port: 3000</span><br></pre></td></tr></table></figure><p>不過這樣我們只能瀏覽 <code>/</code>，接著我們來做點進階的吧！</p><h4 id="step-1-設定-Router"><a href="#step-1-設定-Router" class="headerlink" title="step 1. 設定 Router"></a>step 1. 設定 Router</h4><p>檔案架構長這樣</p><p>會多兩個檔案，</p><p><code>router.rb</code> 設定哪個 route 會回傳什麼訊息<br><code>application.rb</code> 依照路徑來做出 Response (呼叫 Rack 規定的 object)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rack_practice</span><br><span class="line">├── public</span><br><span class="line">│  └──index.html.erb</span><br><span class="line">├── router.rb</span><br><span class="line">├── application.rb</span><br><span class="line">├── Gemfile</span><br><span class="line">├── Gemfile.lock</span><br><span class="line">└── config.ru</span><br></pre></td></tr></table></figure><p>Router 初始化的時候是個空的 {} ，這邊裝的資料會是 Response 的 body</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># router.rb</span><br><span class="line"></span><br><span class="line">class Router</span><br><span class="line">  def initialize</span><br><span class="line">    @routes = &#123;&#125;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>接著要要設定一個方法，放置渲染的訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># router.rb</span><br><span class="line"></span><br><span class="line">class Router</span><br><span class="line">  def initialize</span><br><span class="line">    @routes = &#123;&#125;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def get(path, &amp;block)</span><br><span class="line">    @routes[path] = block</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>最後建立一個 Response ，將對應的訊息回傳</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># router.rb</span><br><span class="line"></span><br><span class="line">class Router</span><br><span class="line">  def initialize</span><br><span class="line">    @routes = &#123;&#125;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def get(path, &amp;block)</span><br><span class="line">    @routes[path] = block</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def build_response(path)</span><br><span class="line">    handler = @routes[path] || -&gt; &#123; &quot;no route found for #&#123;path&#125;&quot; &#125; </span><br><span class="line">    handler.call</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>以上我們就做好 Router 了，接著要來路徑所對應的訊息內容</p><h4 id="step-2-設定-Application"><a href="#step-2-設定-Application" class="headerlink" title="step 2. 設定 Application"></a>step 2. 設定 Application</h4><p>一開始 Application 被 new 出來的時候，要做一個 Router ，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require &quot;./router.rb&quot;</span><br><span class="line"></span><br><span class="line">class Application</span><br><span class="line">  attr_reader :router</span><br><span class="line"></span><br><span class="line">  def initialize</span><br><span class="line">    @router = Router.new</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>接著會使用到 <code>Router.rb</code> 裡面的 <code>get</code> 方法來設定對應的渲染訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">require &quot;./router.rb&quot;</span><br><span class="line"></span><br><span class="line">class Application</span><br><span class="line">  attr_reader :router</span><br><span class="line"></span><br><span class="line">  def initialize</span><br><span class="line">    @router = Router.new</span><br><span class="line"></span><br><span class="line">    @router.get(&#x27;/&#x27;) &#123; &#x27;Welcome to Rack Practice&#x27;&#125;</span><br><span class="line">    @router.get(&#x27;/article&#x27;) &#123; &#x27;All Articles&#x27; &#125; </span><br><span class="line">    @router.get(&#x27;/article/1&#x27;) &#123; &#x27;First Articles&#x27; &#125; </span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>這時候 @router 會長這樣</p><p>每個路徑會指向一個 <code>Proc</code>，而這個 <code>Proc</code> 就會放置我們給他的訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;/&quot;=&gt;#&lt;Proc:0x000000010aed8ce8   </span><br><span class="line">  /Users/.../rack_practice/application.rb:9&gt;, </span><br><span class="line">  &quot;/article&quot;=&gt;#&lt;Proc:0x000000010aed8c98 </span><br><span class="line">  /Users/.../rack_practice/application.rb:10&gt;, </span><br><span class="line">  &quot;/article/1&quot;=&gt;#&lt;Proc:0x000000010aed8c48 </span><br><span class="line">  /Users/.../rack_practice/application.rb:11&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>設定完成後，我們就可以來做 Response 了</p><p>進入到這些畫面的時候</p><p>status 會是 200<br>headers 都是 “text&#x2F;html”<br>只有 body 會不一樣，會像上一步做的，依照進入的頁面不同，渲染不同的訊息</p><p>這時候我們會需要用到 <code>Router.rb</code> 中的  <code>build_response</code><br>將 <code>env[&#39;PATH_INFO&#39;]</code> 當參數傳進去，<br><code>build_response</code> 就會去判斷他是 @router 中的哪個路徑，<br>並依照路徑渲染訊息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">require &quot;./router.rb&quot;</span><br><span class="line"></span><br><span class="line">class Application</span><br><span class="line">  attr_reader :router</span><br><span class="line"></span><br><span class="line">  def initialize</span><br><span class="line">    @router = Router.new</span><br><span class="line"></span><br><span class="line">    @router.get(&#x27;/&#x27;) &#123; &#x27;Welcome to Rack Practice&#x27;&#125;</span><br><span class="line">    @router.get(&#x27;/article&#x27;) &#123; &#x27;All Articles&#x27; &#125; </span><br><span class="line">    @router.get(&#x27;/article/1&#x27;) &#123; &#x27;First Articles&#x27; &#125; </span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def call(env)</span><br><span class="line">    headers = &#123;</span><br><span class="line">      &quot;Content-Type&quot; =&gt; &quot;text/html&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response = @router.build_response(env[&#x27;PATH_INFO&#x27;])</span><br><span class="line"></span><br><span class="line">    [200, headers, [response]]</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="step-3-設定進入點"><a href="#step-3-設定進入點" class="headerlink" title="step 3. 設定進入點"></a>step 3. 設定進入點</h4><p>我們只要將 <code>Rack::Builder</code> 中改成 <code>run Application.new</code><br>在跑 <code>rackup</code> 指令的時候，就會去 new 一個 Application ，並且 run 起來囉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># config.ru</span><br><span class="line"></span><br><span class="line">require &#x27;webrick&#x27;</span><br><span class="line">require &#x27;./application&#x27;</span><br><span class="line"></span><br><span class="line">app = Rack::Builder.new do</span><br><span class="line">  run Application.new</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Signal.trap &#x27;INT&#x27; do</span><br><span class="line">  Rack::Handler::WEBrick.shutdown</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Rack::Handler::WEBrick.run app, Port: 3000</span><br></pre></td></tr></table></figure><p>以上是比較陽春的 Router ，要達到 Rails 的版本還有很多東西要處理，這部分我們之後會再介紹</p><p>參考</p><p><a href="https://github.com/rack/rack">https://github.com/rack/rack</a></p><p><a href="https://tommaso.pavese.me/2016/07/26/a-rack-application-from-scratch-part-2-routes-and-controllers/">https://tommaso.pavese.me/2016/07/26/a-rack-application-from-scratch-part-2-routes-and-controllers/</a></p><p><a href="https://www.writesoftwarewell.com/build-your-own-router-in-ruby/">https://www.writesoftwarewell.com/build-your-own-router-in-ruby/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在之前 Rebuild Rails 時有介紹到 &lt;a href=&quot;https://ninglab.com/%E5%BE%9E0%E9%96%8B%E5%A7%8B%E5%88%BB-%E6%B7%BA%E8%AB%87-Rails-%E7%9A%84%E9%81%8B%E4</summary>
      
    
    
    
    <category term="Ruby" scheme="http://ninglab.com/categories/Ruby/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript - 運行背後的世界(1)</title>
    <link href="http://ninglab.com/JavaScript-execution-context-1/"/>
    <id>http://ninglab.com/JavaScript-execution-context-1/</id>
    <published>2024-03-31T15:41:20.000Z</published>
    <updated>2024-04-10T17:56:29.248Z</updated>
    
    <content type="html"><![CDATA[<p>當 JavaScript 開始執行的時候，背後會做一連串複雜的事情，我們今天就來看看這背後複雜的流程吧</p><p><img src="https://imgur.com/nsX7yj6.jpg" alt="Ning-draw (4)"></p><p>JS 開始運行時，就會啟動<code>執行環境</code></p><h3 id="Execution-Context-執行環境"><a href="#Execution-Context-執行環境" class="headerlink" title="Execution Context 執行環境"></a>Execution Context 執行環境</h3><blockquote><p>An execution context is a specification device that is used to track the runtime evaluation of code by an ECMAScript implementation.</p></blockquote><p>依照 ECMA 官方的解釋，執行環境是在程式碼執行的時候發生，並且用來追蹤程式碼的執行狀況</p><p>而執行環境又分成兩種，分別是<br><code>Global Execution Context</code><br><code>Function Execution Context</code></p><p>當程式碼開始執行時，<code>Global Execution Context</code> 就會開始，他的作用域在程式碼開始到結束</p><h3 id="Global-Execution-Context-GEC"><a href="#Global-Execution-Context-GEC" class="headerlink" title="Global Execution Context (GEC)"></a>Global Execution Context (GEC)</h3><p>又稱作全域執行環境，這個時候，會將 window 做出來，並且將 this 綁定在 window 身上</p><p>我們可以在檢查中輸入 <code>window</code> <code>this</code>，並且看他們兩個是否是一一樣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; window </span><br><span class="line">&gt; this</span><br><span class="line"></span><br><span class="line">&gt; window === this // true</span><br></pre></td></tr></table></figure><p>另外還會將變數存放到「倉庫」中，</p><p>倉庫又分成兩種，</p><ol><li>LexicalEnvironment 存放 <code>let</code> &#x2F; <code>const</code> &#x2F; <code>function</code></li><li>VariableEnvironment 存放 <code>var</code></li></ol><p>我們先知道有這兩個倉庫，待會再來仔細介紹這兩個倉庫</p><p>全域執行環境會一路到程式碼結束，那另一個執行環境呢？</p><h3 id="Function-Execution-Context-FEC"><a href="#Function-Execution-Context-FEC" class="headerlink" title="Function Execution Context (FEC)"></a>Function Execution Context (FEC)</h3><p>又稱為函式執行環境，當程式碼遇到 Function 或 block 時，就會產生 <code>Function Execution Context</code> ，</p><p>跟全域執行環境一樣，會將 function 中的變數及 function 存到倉庫中</p><p>到現在應該對於執行環境還有一點不了解，讓我們用 Stack 來看會更清楚</p><p>來看看下面的程式碼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function aboutMe() &#123;</span><br><span class="line">  console.log(&quot;Hi, my name is Ning&quot;);</span><br><span class="line"></span><br><span class="line">  function myAge() &#123;</span><br><span class="line">    console.log(&quot;I&#x27;m 18 years old&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">aboutMe();</span><br></pre></td></tr></table></figure><p>當程式碼開始執行時，就像是大隊接力開始，執行到哪行程式碼，就是將控制所有權交給該 <code>Execution Context</code></p><ol><li><p>開始執行時，第一棒會是 <code>Global Execution Context</code>，</p></li><li><p>接著執行 <code>aboutMe()</code> ，產生一個 <code>Function Execution Context</code> ，並將所有權交給 <code>aboutMe()</code></p></li><li><p>接著在 <code>aboutMe()</code> 中執行了 <code>myAge()</code> ，因此產生一個新的 <code>Function Execution Context</code> ，並將所有權交給 <code>myAge()</code></p></li><li><p>當 <code>myAge()</code> 執行完後，<code>Function Execution Context</code> 就會消失，並且將控制權轉還交給 <code>aboutMe()</code> </p></li><li><p><code>aboutMe()</code> 執行後，<code>Function Execution Context</code> 就會消失，並將控制權轉交給 <code>Global Execution Context</code></p></li></ol><p><img src="https://imgur.com/uKucytz.jpg" alt="Ning-draw (10)"></p><p>接著我們要來看每個 <code>Execution Context</code> 中做了哪些事</p><p>剛剛有提到，不管是 <code>Global Execution Context</code> 還是 <code>Function Execution Context</code> 都會將他們的變數放到倉庫中</p><p>倉庫還會分成兩種倉庫</p><p>我們先來看第一種 <code>Lexical Environment</code></p><h3 id="Lexical-Environment"><a href="#Lexical-Environment" class="headerlink" title="Lexical Environment"></a>Lexical Environment</h3><p>Lexical Environment 又稱作詞彙環境，</p><p>會放置 <code>let</code> &#x2F; <code>const</code> &#x2F; <code>function</code> 不過還會有個地方放置父層的變數，</p><p>當執行的時候需要這個作用域沒有定義的變數，就可以往父層的變數小房間去找</p><p>因此 Lexical Environment 又分成兩個小盒子</p><p>第一個盒子是 <code>Environment Record</code>，放置 <code>let</code> &#x2F; <code>const</code> &#x2F; <code>function</code> 等變數</p><p>第二個盒子是 <code>reference to outer environment</code>，放置父層的變數</p><p>讓我們來看看幾個例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function aboutMe() &#123;</span><br><span class="line">  var myName = &quot;Ning&quot;;</span><br><span class="line">  console.log(`Hi, my name is $&#123;myName&#125;`);</span><br><span class="line"></span><br><span class="line">  function myAge() &#123;</span><br><span class="line">    let age = 18;</span><br><span class="line">    console.log(`I&#x27;m $&#123;age&#125; years old`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aboutMe();</span><br></pre></td></tr></table></figure><ol><li>呼叫 <code>AboutMe()</code></li><li>進入到 <code>AboutMe</code> 的 <code>Function Execution Context</code></li><li>放置變數及 Function 到倉庫中， <code>myName</code> &#x2F; <code>myAge</code> <ul><li><code>myName</code> 是 var 變數，因此會放到 <code>Variable Environment</code> (待會會提到)</li><li><code>myAge</code> 是 Function ，會放到 <code>Environment Record</code></li></ul></li><li>印出 <code>Hi, my name is $&#123;myName&#125;</code>，由於 <code>Variable Environment</code> 有 <code>myName</code> 變數，因此印出 <code>Hi, my name is Ning</code></li><li>呼叫 <code>myAge()</code></li><li>進入 <code>myAge</code> 的 <code>Function Execution Context</code></li><li>放置變數<ul><li><code>age</code> 是 let 變數，因此放到 <code>Environment Record</code></li></ul></li><li>印出 <code>I&#39;m $&#123;age&#125; years old</code> ，這時候 <code>myAge</code> 的 <code>Environment Record</code> 有 <code>age</code> 這個變數，因此印出  <code>I&#39;m 18 years old</code></li></ol><p><img src="https://imgur.com/k2mgVMy.jpg" alt="Ning-draw (6)"></p><p>接著我們來看有使用到父層變數的程式碼</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function aboutMe() &#123;</span><br><span class="line">  var myName = &quot;Ning&quot;;</span><br><span class="line">  let age = 18;</span><br><span class="line">  console.log(`Hi, my name is $&#123;myName&#125;`);</span><br><span class="line"></span><br><span class="line">  function myAge() &#123;</span><br><span class="line">    console.log(`I&#x27;m $&#123;age&#125; years old`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aboutMe();</span><br></pre></td></tr></table></figure><ol><li>呼叫 <code>AboutMe()</code></li><li>進入到 <code>AboutMe</code> 的 <code>Function Execution Context</code></li><li>放置變數及 Function 到倉庫中， <code>myName</code> &#x2F; <code>age</code> &#x2F; <code>myAge</code> <ul><li><code>myName</code> 是 var 變數，因此會放到 <code>Variable Environment</code></li><li><code>age</code> 是 let 變數，因此會放到 <code>Environment Record</code></li><li><code>myAge</code> 是 Function ，會放到 <code>Environment Record</code></li></ul></li><li>印出 <code>Hi, my name is $&#123;myName&#125;</code>，由於 <code>Variable Environment</code> 有 <code>myName</code> 變數，因此印出 <code>Hi, my name is Ning</code></li><li>呼叫 <code>myAge()</code></li><li>進入 <code>myAge</code> 的 <code>Function Execution Context</code></li><li>沒有變數</li><li>印出 <code>I&#39;m $&#123;age&#125; years old</code> ，這時候 <code>myAge</code> 的 <code>Environment Record</code> 沒有 <code>age</code> 這個變數，因此往 <code>reference to outer environment</code> 找變數，在 <code>aboutMe</code> 找到了 age 是 18，因此印出 <code>I&#39;m 18 years old</code></li></ol><p>要注意的是， <code>reference to outer environment</code> 只會放上一層的，如果沒有的話，就會從上一層的 <code>reference to outer environment</code> 繼續往上找</p><p><img src="https://imgur.com/7qkuMF5.jpg" alt="Ning-draw (7)"></p><p>接著我們來看看 <code>Variable Environment</code></p><h3 id="Variable-Environment"><a href="#Variable-Environment" class="headerlink" title="Variable Environment"></a>Variable Environment</h3><p>又稱作變數環境，主要放置 <code>var</code> 變數，</p><p>接下來再看一個範例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function aboutMe() &#123;</span><br><span class="line">  var myName = &quot;Ning&quot;;</span><br><span class="line"></span><br><span class="line">  function myAge() &#123;</span><br><span class="line">    console.log(`I&#x27;m $&#123;age&#125; years old`);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (myName == &quot;Ning&quot;) &#123;</span><br><span class="line">    let age = 19;</span><br><span class="line">    myAge();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aboutMe();</span><br></pre></td></tr></table></figure><ol><li>執行 <code>aboutMe()</code></li><li>進入 <code>aboutMe</code> 的 <code>Function Execution Context</code> </li><li>放置變數 <ul><li>放置 var 變數 <code>myName</code> 到 <code>Variable Environment</code></li><li>放置 Function <code>myAge</code> 到 <code>Lexical Environment</code></li></ul></li><li>遇到 if 的 block ，進入該 block 的 <code>Function Execution Context</code></li><li>放置變數 <code>age</code> 到 <code>Lexical Environment</code></li><li>執行 <code>myAge()</code></li><li>進入 <code>myAge</code> 的 <code>Function Execution Context</code></li><li>沒有變數，不放置變數</li><li>印出 <code>I&#39;m $&#123;age&#125; years old</code>，不過該 <code>Execution Context</code> 沒有任何變數，往 <code>reference to outer environment</code> 找</li><li>在 <code>aboutMe</code> 中找不到</li><li>因此印出錯誤訊息 <code>Uncaught ReferenceError: age is not defined</code></li></ol><p><img src="https://imgur.com/W0ss9O1.jpg" alt="Ning-draw (8)"></p><p>為什麼不是往 <code>if (myName == &quot;Ning&quot;)</code><br>主要是因為 JavaScript 是採用 Lexical Scope 的方式，</p><blockquote><p>The word lexical refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available.</p></blockquote><p>根據 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#lexical_scoping">MDN</a> 的解釋，Lexical Scope 會取決於該程式碼的 <code>所在位置</code>，而非程式碼的 <code>執行位置</code></p><p>也就是說，我們要看的是 <code>myAge</code> 位在於程式碼的哪裡，並且去找到他的父層，而他的父層就是 <code>aboutMe</code>，</p><p>因此 <code>reference to outer environment</code> 這個倉庫也只會放 <code>aboutMe</code> 的變數</p><p>看到這邊應該有個疑惑，為什麼 <code>if (myName == &quot;Ning&quot;)</code> 的 var 會被放在 <code>aboutMe</code> 的 <code>Variable Environment</code> ？</p><p>依照 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/var">MDN</a> 的說明， var 只能被包在 <code>Function</code> 中，一旦出了 <code>Function</code> 這個作用域，就會變成 <code>Global</code> 作用域</p><p>關於 <code>Variable Environment</code> 的詳細介紹，將在下篇文章提出</p><p>參考<br><a href="https://www.borderlessengineer.com/p/how-js-works-understanding-the-execution">https://www.borderlessengineer.com/p/how-js-works-understanding-the-execution</a></p><p><a href="https://www.freecodecamp.org/news/javascript-execution-context-and-hoisting/">https://www.freecodecamp.org/news/javascript-execution-context-and-hoisting/</a></p><p><a href="https://www.frontendmag.com/tutorials/lexical-environment-in-javascript/">https://www.frontendmag.com/tutorials/lexical-environment-in-javascript/</a></p><p><a href="https://262.ecma-international.org/6.0/#sec-execution-contexts">https://262.ecma-international.org/6.0/#sec-execution-contexts</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#lexical_scoping">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#lexical_scoping</a></p>]]></content>
    
    
    <summary type="html">JavaScript 運行背後到底做了哪些事，所謂的 Execution Context 又是什麼？</summary>
    
    
    
    <category term="JavaScript" scheme="http://ninglab.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Rails - Turbo 與 Turbo Drive</title>
    <link href="http://ninglab.com/Rails-Turbo-and-Turbo%20Drive/"/>
    <id>http://ninglab.com/Rails-Turbo-and-Turbo%20Drive/</id>
    <published>2024-03-03T17:53:18.000Z</published>
    <updated>2024-03-31T15:41:00.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Turbo"><a href="#Turbo" class="headerlink" title="Turbo"></a>Turbo</h1><h2 id="瀏覽器的載入模式"><a href="#瀏覽器的載入模式" class="headerlink" title="瀏覽器的載入模式"></a>瀏覽器的載入模式</h2><p>在 AJAX 還沒出現以前，使用者在瀏覽網頁，進行互動後，需要重新整理才會在網頁上看到互動後的結果</p><p><img src="https://i.imgur.com/CFwObAB.jpeg"></p><h2 id="AJAX-模式"><a href="#AJAX-模式" class="headerlink" title="AJAX 模式"></a>AJAX 模式</h2><p>AJAX 的全名為 Asynchronous JavaScript and XML ，這些字詞的意思為 非同步 JavaScript 與 XML</p><p>非同步 JavaScript 大家應該都不陌生，指的是不需要等待上一個任務執行完再執行下一個，因此系統同時可以處理多個任務</p><p>而 AJAX 使用 XMLHttpRequest 來發送 Request，格式是採用 XML 格式</p><p>回傳的 Response 可以採用 XML 或者是 JSON ，現階段大多以 JSON 格式回傳</p><p><img src="https://i.imgur.com/vxXZ5xN.jpeg"></p><p>如此一來，就能馬上渲染資料</p><p><img src="https://i.imgur.com/h0MzwaM.gif" alt="giphy"></p><p>讓我們用 JS 的角度來看一下 AJAX 會是怎麼發送的，就會比較好理解 Turbo 的原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const button = document.getElementById(&quot;button&quot;)</span><br><span class="line"></span><br><span class="line">button.addEventListener(&#x27;click&#x27;, function()&#123;</span><br><span class="line">  let xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">  xhr.open(&#x27;GET&#x27;, &#x27;ajax.txt&#x27;, true);</span><br><span class="line"></span><br><span class="line">  xhr.send();</span><br><span class="line"></span><br><span class="line">  xhr.onload = function()&#123;</span><br><span class="line">    if (this.status == 200) &#123;</span><br><span class="line">      let text = document.getElementById(&quot;text&quot;)</span><br><span class="line">      text.innerHTML = this.responseText</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其實原理跟一般的事件監聽很像，<br>差別在於 <code>XMLHttpRequest</code> 會透過 url 來獲取資料，<br>而 <code>xhr.open</code> 第三個參數指的是是否採取同步或非同步，<br><code>true</code> 表示採取非同步</p><p>所以後續的程式碼都會一起執行，<br>並且及時地將拿回來的 Response 資料渲染</p><h2 id="關於-Turbo"><a href="#關於-Turbo" class="headerlink" title="關於 Turbo"></a>關於 Turbo</h2><p>Rails 透過 Turbo 來加速網頁的載入速度，</p><p>Turbo 是 AJAX 技術的應用，但他做的事會比 AJAX 更多</p><p>而 Turbo 又分成幾個功能</p><ol><li><p>Turbo Drive<br>加速載入頁面，讓使用者感受不到頁面之間的切換</p></li><li><p>Turbo Frame<br>不需要寫大量的 DOM 元素就能在同樣的頁面渲染表單或資訊</p></li><li><p>Turbo Stream<br>透過 Action Cable 即時渲染 Response 的內容</p></li><li><p>Turbo Native<br>用 Turbo 來打造 App (不過目前尚未設略，暫時不介紹)</p></li></ol><p>今天我們會先介紹 Turbo Drive</p><h2 id="關於-Turbo-Drive"><a href="#關於-Turbo-Drive" class="headerlink" title="關於 Turbo Drive"></a>關於 Turbo Drive</h2><p>Turbo Drive 就是以前的 Turbolinks</p><p>用 Rails 寫過專案的人應該多少都遇過在點擊連結的時候完全沒作用，是因為 Turbolinks 把所有的連結預設事件都停掉了，在 Rails 5 ~ Rails 6 版本的專案，我們可以用 <code>data-turbo=&quot;false&quot;</code> 來停掉連結的 Turbolinks</p><p>而在 Rails 7 中， Turbo Drive 不只將連結的預設事件停掉，連表單的預設事件也被停掉了，這樣做的目的是為了提高載入的速度！</p><p>只要掌握 Turbo Drive 的原理，它就會很好用！</p><h3 id="從-Visit-開始的生命週期"><a href="#從-Visit-開始的生命週期" class="headerlink" title="從 Visit 開始的生命週期"></a>從 Visit 開始的生命週期</h3><p>在使用者點擊的那一刻， Turbo Drive 的生命週期就開始了，一直到 render 完頁面才結束</p><p>Turbo Drive 在 render 的時候會做以下這幾件事情</p><ol><li>將 body 換成 Response 的 body</li><li>如果 head 的 title 以及 meta 改變，會將 head 合併，反之，head 將保持原樣</li><li>有需要的話會將 html 的 lang 標籤更新</li><li>除此之外，還會將 URL 更換掉</li></ol><p>Turbo 會有幾個生命週期，</p><p><code>turbo:click</code><br><code>turbo:before-visit</code><br><code>turbo:visit</code><br><code>turbo:before-cache</code><br><code>turbo:before-render</code><br><code>turbo:render</code><br><code>turbo:load</code></p><p>我們先來看前置作業，當點擊連結，並且拜訪 URL 以前，忙碌的 Turbo 做了哪些事</p><h3 id="session-visit-Turbo-開始"><a href="#session-visit-Turbo-開始" class="headerlink" title="session.visit - Turbo 開始"></a>session.visit - Turbo 開始</h3><p>當點擊時， Turbo 會先去判斷是否為 turbo frame，不是的話就會去拜訪該 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// src/core/session.js:97</span><br><span class="line"></span><br><span class="line">visit(location, options = &#123;&#125;) &#123;</span><br><span class="line">  const frameElement = options.frame ? document.getElementById(options.frame) : null</span><br><span class="line"></span><br><span class="line">  if (frameElement instanceof FrameElement) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.navigator.proposeVisit(expandURL(location), options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Navigator-停止預設事件"><a href="#Navigator-停止預設事件" class="headerlink" title="Navigator - 停止預設事件"></a>Navigator - 停止預設事件</h3><p>開始導去 URL 的時候，會先判斷該 URL 是否為同一頁，或者不同頁但是觸發 <code>turbo:before-visit</code> 事件，並且把預設事件停掉，就會開始接下來的訪問</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/navigator.js:12</span><br><span class="line"></span><br><span class="line">proposeVisit(location, options = &#123;&#125;) &#123;</span><br><span class="line">  if (this.delegate.allowsVisitingLocationWithAction(location, options.action)) &#123;</span><br><span class="line">    this.delegate.visitProposedToLocation(location, options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Session-開始拜訪"><a href="#Session-開始拜訪" class="headerlink" title="Session - 開始拜訪"></a>Session - 開始拜訪</h3><p>在這個階段會先將 URL 做新舊版本的轉換，避免舊版本無法支援(這邊的版本是指 Turbo Native 的 adapter)<br>接著就會請瀏覽器去拜訪了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// src/core/session.js:239</span><br><span class="line"></span><br><span class="line">visitProposedToLocation(location, options) &#123;</span><br><span class="line">  extendURLWithDeprecatedProperties(location)</span><br><span class="line">  this.adapter.visitProposedToLocation(location, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Browser-Adapter-拜訪前的敲門鈴確認"><a href="#Browser-Adapter-拜訪前的敲門鈴確認" class="headerlink" title="Browser Adapter - 拜訪前的敲門鈴確認"></a>Browser Adapter - 拜訪前的敲門鈴確認</h3><p>這時候 Turbo 會去確認 URL 的網域是不是一致的，一致才會繼續拜訪</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// src/core/native/browser_adapter.js:13</span><br><span class="line"></span><br><span class="line">visitProposedToLocation(location, options) &#123;</span><br><span class="line">  if (locationIsVisitable(location, this.navigator.rootLocation)) &#123;</span><br><span class="line">    this.navigator.startVisit(location, options?.restorationIdentifier || uuid(), options)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    window.location.href = location.toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Navigator-點下連結後的導向"><a href="#Navigator-點下連結後的導向" class="headerlink" title="Navigator - 點下連結後的導向"></a>Navigator - 點下連結後的導向</h3><p>在導向新的 URL 時，就會透過 expendURL 將 URL 設定成新的，不過不是在這邊換掉，是在 Visit 開始的時候才會換掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/navigator.js:18</span><br><span class="line"></span><br><span class="line">startVisit(locatable, restorationIdentifier, options = &#123;&#125;) &#123;</span><br><span class="line">  this.stop()</span><br><span class="line">  this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, &#123;</span><br><span class="line">    referrer: this.location,</span><br><span class="line">    ...options</span><br><span class="line">  &#125;)</span><br><span class="line">  this.currentVisit.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// src/core/url.js:1</span><br><span class="line"></span><br><span class="line">export function expandURL(locatable) &#123;</span><br><span class="line">  return new URL(locatable.toString(), document.baseURI)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Visit-Turbo-Drive-開始生效"><a href="#Visit-Turbo-Drive-開始生效" class="headerlink" title="Visit - Turbo Drive 開始生效"></a>Visit - Turbo Drive 開始生效</h3><p>當確認好狀態為 <code>initialized</code> 並且定義完基本設定後，就會開始了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/visit.js:117</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">  if (this.state == VisitState.initialized) &#123;</span><br><span class="line">    this.recordTimingMetric(TimingMetric.visitStart)</span><br><span class="line">    this.state = VisitState.started</span><br><span class="line">    this.adapter.visitStarted(this)</span><br><span class="line">    this.delegate.visitStarted(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Browser-Adapter-改頭換面的開始"><a href="#Browser-Adapter-改頭換面的開始" class="headerlink" title="Browser Adapter - 改頭換面的開始"></a>Browser Adapter - 改頭換面的開始</h3><p>當開始 Visit 時，第一件事會將 URL 換掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// src/core/native/browser_adapter.js:21</span><br><span class="line"></span><br><span class="line">visitStarted(visit) &#123;</span><br><span class="line">  this.location = visit.location</span><br><span class="line">  visit.loadCachedSnapshot()</span><br><span class="line">  visit.issueRequest()</span><br><span class="line">  visit.goToSamePageAnchor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著 Turbo Drive 需要判斷連結有沒有在 Cached 中，有的話就會直接渲染 Cached 中的頁面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/visit.js:247</span><br><span class="line"></span><br><span class="line">loadCachedSnapshot() &#123;</span><br><span class="line">  const snapshot = this.getCachedSnapshot()</span><br><span class="line">  if (snapshot) &#123;</span><br><span class="line">    const isPreview = this.shouldIssueRequest()</span><br><span class="line">    this.render(async () =&gt; &#123;</span><br><span class="line">      this.cacheSnapshot()</span><br><span class="line">      if (this.isSamePage || this.isPageRefresh) &#123;</span><br><span class="line">        this.adapter.visitRendered(this)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (this.view.renderPromise) await this.view.renderPromise</span><br><span class="line"></span><br><span class="line">        await this.renderPageSnapshot(snapshot, isPreview)</span><br><span class="line"></span><br><span class="line">        this.adapter.visitRendered(this)</span><br><span class="line">        if (!isPreview) &#123;</span><br><span class="line">          this.complete()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著會去看 Cached 是否已經有 Response ，<br>有的話就會模擬之前的 Request ，<br>沒有的話就會發送一個新的 Request</p><p>為什麼可以先載入 Response ，可參考此 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent/preloadResponse">MDN 的說明</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/visit.js:166</span><br><span class="line"></span><br><span class="line">issueRequest() &#123;</span><br><span class="line">  if (this.hasPreloadedResponse()) &#123;</span><br><span class="line">    this.simulateRequest()</span><br><span class="line">  &#125; else if (this.shouldIssueRequest() &amp;&amp; !this.request) &#123;</span><br><span class="line">    this.request = new FetchRequest(this, FetchMethod.get, this.location)</span><br><span class="line">    this.request.perform()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再來就是判斷新 URL 跟目前所在的頁面是否為同一頁，<br>同一頁的話就會挪到指定的 Anchor </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/visit.js:281</span><br><span class="line"></span><br><span class="line">  goToSamePageAnchor() &#123;</span><br><span class="line">    if (this.isSamePage) &#123;</span><br><span class="line">      this.render(async () =&gt; &#123;</span><br><span class="line">        this.cacheSnapshot()</span><br><span class="line">        this.performScroll()</span><br><span class="line">        this.changeHistory()</span><br><span class="line">        this.adapter.visitRendered(this)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Session-拜訪"><a href="#Session-拜訪" class="headerlink" title="Session - 拜訪"></a>Session - 拜訪</h3><p>接著</p><p>假設目前的 Visit 並沒有接受 Stream 格式的 Response ，就將它標記為正在處理中，這個處理可能是在處理 Request 以及換頁，</p><p>總之，不是以 Turbo Drive 的方式去處理</p><p>接著會判斷是在看是不是為同一頁，同一頁的話就會觸發 <code>turbo:visit</code> 並訪問該 URL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// src/core/session.js:246</span><br><span class="line"></span><br><span class="line">  visitStarted(visit) &#123;</span><br><span class="line">    if (!visit.acceptsStreamResponse) &#123;</span><br><span class="line">      markAsBusy(document.documentElement)</span><br><span class="line">      this.view.markVisitDirection(visit.direction)</span><br><span class="line">    &#125;</span><br><span class="line">    extendURLWithDeprecatedProperties(visit.location)</span><br><span class="line">    if (!visit.silent) &#123;</span><br><span class="line">      this.notifyApplicationAfterVisitingLocation(visit.location, visit.action)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上只是渲染之前所做的事情 ( 實際上要處理的應該遠比我提的更多，我這邊只先提個大致的流程 )</p><h3 id="不同的-Visit"><a href="#不同的-Visit" class="headerlink" title="不同的 Visit"></a>不同的 Visit</h3><p>Turbo Drive 又分成兩種 Visit</p><p>一種是 <code>Application Visits</code> ，另一種是 <code>Restoration Visits</code></p><p>在這之前我們可以來了解一下 Turbo Drive 處理 Cached 的機制</p><p>Turbo Drive 會將最近造訪過的 URL 暫存，有兩個目的</p><ol><li>在歷史紀錄中切換 URL ( 即所謂的 Restoration Visits  ) 的時候，不需要發送 Request 就能渲染</li><li>在一般的 URL 切換中，能快速渲染頁面(但還是會發送 Request)，讓使用者感受不到有在切換</li></ol><p>Application Visits 將會發送 Request ，並且如果 Cached 有該 URL 頁面資訊的話，就會渲染頁面資訊</p><p>Restoration Visits<br>使用者點擊了瀏覽器的上一頁，或是下一頁，因為已經瀏覽過， Cached 中可能會有資料，所以就不會發送 Request ，而是直接 render Cached 裡面的頁面資訊</p><p>上述兩種 Visit 最大的差別應該是在於是否為歷史紀錄中的切換以及是否有發送 Request</p>]]></content>
    
    
    <summary type="html">使用 Rails 7 ，Turbo 讓你的網頁比別人更快</summary>
    
    
    
    <category term="Rails" scheme="http://ninglab.com/categories/Rails/"/>
    
    
  </entry>
  
  <entry>
    <title>工程師都該懂的程式通識 - Proxy</title>
    <link href="http://ninglab.com/proxy/"/>
    <id>http://ninglab.com/proxy/</id>
    <published>2024-02-22T15:07:31.000Z</published>
    <updated>2024-02-23T17:41:45.516Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家從小到大應該都會碰到代理伺服器，代理伺服器就像是我們生活中的代理人一樣，會代表著 Client 端或者 Server 端</p><p>我們就來進入正題吧</p><h3 id="什麼是代理伺服器"><a href="#什麼是代理伺服器" class="headerlink" title="什麼是代理伺服器"></a>什麼是代理伺服器</h3><p>在 10 年前，大家點開 ie 的頁面都是 Yahoo ，</p><p>網路速度不比現在，都需要等個一兩分鐘，</p><p>等個一兩次還好，不過等太多次難免會覺得很煩，</p><p>每次點開都需要重新發送請求，然後再等一次</p><p><img src="https://hackmd.io/_uploads/HyojT_VPa.jpg" alt="Ning-draw (7)"></p><p>這時候代理伺服器就出現了，代理伺服器就像是班代的角色，</p><p>會代替使用者去跟 Server 端發送請求，</p><p>並且將要來的資料在自己身上暫存一份，</p><p>等到下個使用者再來請求的時候，就將這份暫存提供給他</p><p><img src="https://hackmd.io/_uploads/BJW6Ad4Pa.jpg" alt="Ning-draw (8)"></p><p>理解了什麼是代理伺服器的概念後，</p><p>我們來看正向代理伺服器跟反向代理伺服器就會簡易許多</p><h3 id="正向代理伺服器-Forward-Proxy"><a href="#正向代理伺服器-Forward-Proxy" class="headerlink" title="正向代理伺服器 Forward Proxy"></a>正向代理伺服器 Forward Proxy</h3><p>正向代理伺服器就跟我們上面提到的代理伺服器是一樣的概念，</p><p>代表 Client 端跟網路發送請求，網路會再將請求傳送給 Server</p><p><img src="https://hackmd.io/_uploads/HyfOiKEDa.jpg" alt="Ning-draw (9)"></p><p>我們用個簡單的例子來說明：</p><p>當考試成績出來後，學生都要一個一個去找老師拿成績單，</p><p>不過一個一個去拿其實蠻麻煩而且沒有效率</p><p>這時候我們就可以推派班代去代替整班的學生跟老師拿成績單</p><h4 id="生活中的應用"><a href="#生活中的應用" class="headerlink" title="生活中的應用"></a>生活中的應用</h4><ol><li>限制能連線的網站：</li></ol><p>以前我們在上電腦課的時候，會想要偷偷連到遊戲網站上玩遊戲，</p><p>不過學校沒有那麼笨，在學校內的電腦，都會設定防火牆，</p><p>當防火牆有設定限制存取的網站，甚至是限制代理伺服器時，</p><p>我們就很難繞過這一層去遊戲網站了</p><p><img src="https://hackmd.io/_uploads/rkaUPuEva.jpg" alt="Ning-draw (2)"></p><ol start="2"><li>保護使用者的資料</li></ol><p>當使用者去瀏覽網站時，網站是可以存取到使用者的資訊的，</p><p>有了代理伺服器這個角色，使用者會透過代理伺服器去發送請求、接受回應，</p><p>所以網站只能知道代理伺服器的資料，並不會知道使用者的資料</p><p><img src="https://hackmd.io/_uploads/ByPOu_Ev6.jpg" alt="Ning-draw (3)"></p><h3 id="反向代理伺服器"><a href="#反向代理伺服器" class="headerlink" title="反向代理伺服器"></a>反向代理伺服器</h3><p>跟正向代理伺服器相反，反向代理伺服器代表的對象就會是 Server 端</p><p><img src="https://hackmd.io/_uploads/HyJEdDVwT.jpg" alt="Ning-draw (1)"></p><p>我們用簡單的例子來說：</p><p>今天有一群人想跟政府陳情，這時候他們的請求會送給代表人，</p><p>代表人會再將這些請求丟給政府的各個機關</p><p>等各個政府機關決議好後，就會將結果傳送給代表人</p><p>由代表人告訴民眾結果</p><h4 id="生活中的應用-1"><a href="#生活中的應用-1" class="headerlink" title="生活中的應用"></a>生活中的應用</h4><ol><li>保護 server</li></ol><p>當 Server 的資訊赤裸的公開時，難免會受到攻擊，</p><p>而反向代理伺服器的角色就能當作 Server 端的擋箭牌，</p><p>避免 Server 端被攻擊</p><p><img src="https://hackmd.io/_uploads/SJ-7juNDT.jpg" alt="Ning-draw (5)"></p><ol start="2"><li>平衡負載</li></ol><p>熱門網站像是 Google 、 Amazon ，一天可能會有上千萬名使用者進站</p><p>只有一個 Server 是不可能負荷得了短時間內有上萬個使用者</p><p>所以一次應該都會有多台 Server 在跑，</p><p>而代理伺服器的角色就會像是交通指揮，指揮哪些請求要去哪個 Server 避免 Server 崩潰</p><p><img src="https://hackmd.io/_uploads/ByUI9dNvp.jpg" alt="Ning-draw (4)"></p><ol start="3"><li>代理 SSL</li></ol><p>當 Client 端發送請求出去後，需要經過 SSL 握手，確保雙方的身份是對的才可以進行下一步</p><p>反向代理伺服器就會幫 Server 充當代理，將加密過的 SSL 訊息解密，之後就會放行請求給 Server</p><p><img src="https://hackmd.io/_uploads/ry7aiu4Pp.jpg" alt="Ning-draw (6)"></p><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>當我們今天要瀏覽的網站是美國的網站，可能這網站的伺服器放在美國，</p><p>地區遙遠的關係會讓我們在存取的時間上拉長，為了把時間花在同一件事上(每次發送請求都要美國的伺服器拿資料)，代理伺服器會將資料快取起來，</p><p>不管是正向代理伺服器還是反向代理伺服器，這兩種類都會提供資料快取，</p><p>會先將資料暫存在代理伺服器中，等到其他使用者需要存取相同的資料時，就會派上用場</p><p>而資料只會暫存一段時間，過一段時間就會消除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相信大家從小到大應該都會碰到代理伺服器，代理伺服器就像是我們生活中的代理人一樣，會代表著 Client 端或者 Server 端&lt;/p&gt;
&lt;p&gt;我們就來進入正題吧&lt;/p&gt;
&lt;h3 id=&quot;什麼是代理伺服器&quot;&gt;&lt;a href=&quot;#什麼是代理伺服器&quot; class=&quot;header</summary>
      
    
    
    
    <category term="程式通識" scheme="http://ninglab.com/categories/%E7%A8%8B%E5%BC%8F%E9%80%9A%E8%AD%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker - 什麼是 Compose</title>
    <link href="http://ninglab.com/Docker-compose-yaml-file/"/>
    <id>http://ninglab.com/Docker-compose-yaml-file/</id>
    <published>2024-02-22T15:04:11.000Z</published>
    <updated>2024-02-23T17:46:27.635Z</updated>
    
    <content type="html"><![CDATA[<p>之前我們介紹了 Dockerfile 的基本指令，</p><p>這次的主題我們要來介紹 docker-compose.yml </p><h3 id="關於-docker-compose-yml"><a href="#關於-docker-compose-yml" class="headerlink" title="關於 docker-compose.yml"></a>關於 docker-compose.yml</h3><h4 id="是什麼？"><a href="#是什麼？" class="headerlink" title="是什麼？"></a>是什麼？</h4><p>官方的說明</p><blockquote><p>Compose is a tool for defining and running multi-container Docker applications. </p></blockquote><p>Compose 是運行多個 container 的工具。</p><p>什麼意思呢？</p><p>如果專案中需要跑多個 container 起來，</p><p>我們就需要使用到 Compose 把他們集結起來，組合成我們的專案。</p><p>用生活中的例子來說明，</p><p>某個工廠有四位成員，</p><p>這四個成員就像是每個 container 一樣，在工廠中付出勞力或心力，</p><p>而 Compose 就像是工廠，</p><p>將這四位成員集中起來，並且保持產線的運作</p><h4 id="什麼時候該用它？"><a href="#什麼時候該用它？" class="headerlink" title="什麼時候該用它？"></a>什麼時候該用它？</h4><blockquote><p>當我們的專案會同時跑多個 container 時，就會需要用到 compose</p></blockquote><p>舉例來說，用 Rails 寫的專案，</p><p>我們需要跑一個 <code>Ruby</code> container，</p><p>要用 <code>Postgresql</code> 作為資料庫的話，就會需要另外再跑一個 container </p><p>那如果不要用呢？</p><p>我們就要用指令一個一個設定 networks 是哪個，是否需要用 volumes </p><p>指令會變成一大串，聽起來其實蠻麻煩的吧</p><h4 id="docker-compose-yml-可以做什麼設定"><a href="#docker-compose-yml-可以做什麼設定" class="headerlink" title="docker-compose.yml 可以做什麼設定"></a>docker-compose.yml 可以做什麼設定</h4><p>docker-compose.yml 可以做很多設定，我們會透過這個檔案，告訴 Docker Compose 需要用哪些服務、要去監聽哪個 ports，甚至是設定環境變數</p><ul><li>version</li></ul><p>docker-compose.yml 是使用哪個版本</p><ul><li>services</li></ul><p>我們會設定這個專案會使用到哪些服務，例如由這個專案包起來的 image、資料庫的 image 等等</p><ul><li>platform</li></ul><p>如果我們要運行的機器是特定的作業系統，就必須在這邊做設定<br>還有一個情況是，假設我們本機的作業系統與機器作業系統不同，也需要設定這個參數</p><ul><li>ports</li></ul><p>Docker 會依照我們設定的 port ，來取決於 Docker 的哪個 port 要去監聽機器上的哪個 port</p><ul><li>environment</li></ul><p>我們也可以在 docker-compose.yml 中設定環境變數。</p><p>不過環境變數什麼時候該在 dockerfile 設定，什麼時候又該在 docker-compose.yml 設定？</p><p>取決於 dockerfile 這顆做出來的 image 是否要重複使用，且環境變數是否一致，一致的話就可以設定在 dockerfile 中，不一致的話我們就可以設定在 docker-compose.yml 中</p><ul><li>restart</li></ul><p>告訴 Docker 什麼時候開重新啟動</p><ul><li>networks</li></ul><p>告訴 Docker 這顆 contailer 是使用哪個 networks </p><ul><li>volumes</li></ul><p>告訴 Docker 這顆 contailer 存放的資料放在哪個 volumes </p><p>以上是我們在寫 docker-compose.yml 常用到的設定</p><p><code>networks</code> 、 <code>volumes</code> 我們將在之後會提到。</p><h3 id="撰寫-docker-compose-yml-檔案"><a href="#撰寫-docker-compose-yml-檔案" class="headerlink" title="撰寫 docker-compose.yml 檔案"></a>撰寫 docker-compose.yml 檔案</h3><p>接著我們來試做一個簡單的 <code>docker-compose.yml</code> 檔案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.9&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    image: &quot;ruby:3.2.0-alpine3.17&quot;</span><br></pre></td></tr></table></figure><p>寫好 docker-compose.yml 後，我們將 image 跑起來</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker compose up</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[+] Running 2/1</span><br><span class="line"> ⠿ Network ishop_default  Created                                                                      0.1s</span><br><span class="line"> ⠿ Container ishop-app-1  Created                                                                      0.0s</span><br><span class="line">Attaching to ishop-app-1</span><br><span class="line">ishop-app-1  | Switch to inspect mode.</span><br><span class="line">ishop-app-1  | </span><br><span class="line">ishop-app-1 exited with code 0</span><br></pre></td></tr></table></figure><h4 id="這個指令背後做了哪些事？"><a href="#這個指令背後做了哪些事？" class="headerlink" title="這個指令背後做了哪些事？"></a>這個指令背後做了哪些事？</h4><p>當我們下了 <code>docker compose up</code> 時， Docker 會先從 docker-compose.yml 解析，並且開始建立 image ，建立完成後就會跑 container</p><p>基本上就是 <code>build</code> + <code>run container</code> 的指令</p><p><img src="https://hackmd.io/_uploads/ryf5H6ff6.jpg"></p><p>那如果我們更新了專案，還要再重新跑一次指令嗎？</p><p>不需要， <code>docker compose</code> 會去查看哪個地方改了，會更新修改的地方並且 <code>recreate container</code></p><p><img src="https://hackmd.io/_uploads/r1NUnTzMT.jpg"></p><h3 id="將-container-停止"><a href="#將-container-停止" class="headerlink" title="將 container 停止"></a>將 container 停止</h3><p>當我們下完以下指令，他就會 stop 所有的 container</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker compose stop</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[+] Running 3/3</span><br><span class="line"> ⠿ Container ning_lab_blog-app-1       Stopped                                                                               0.4s</span><br><span class="line"> ⠿ Container ning_lab_blog-traefik-1   Stopped                                                                               0.0s</span><br><span class="line"> ⠿ Container ning_lab_blog-database-1  Stopped                                                                               0.3s</span><br></pre></td></tr></table></figure><h3 id="將-Docker-Compose-中的-container-清理掉"><a href="#將-Docker-Compose-中的-container-清理掉" class="headerlink" title="將 Docker Compose 中的 container 清理掉"></a>將 Docker Compose 中的 container 清理掉</h3><p>如果我們要將所有 container 刪除，就可以使用這個指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker compose down</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[+] Running 3/3</span><br><span class="line"> ⠿ Container ning_lab_blog-app-1       Removed                                                                               0.0s</span><br><span class="line"> ⠿ Container ning_lab_blog-traefik-1   Removed                                                                               0.0s</span><br><span class="line"> ⠿ Container ning_lab_blog-database-1  Removed                                                                               0.0s</span><br></pre></td></tr></table></figure><p>什麼時候要用 docker compose stop 什麼時候要用 docker compose down ?</p><p><img src="https://hackmd.io/_uploads/SkXDn6MMa.jpg"></p><p>以我自己的習慣，如果只是要讓專案暫停，就會使用 <code>docker compose stop</code></p><p>但如果我今天是要重新建立 image 並且重跑，就會使用 <code>docker compose down</code> 請他將 Docker Compose 清乾淨</p><h3 id="將-image-建立並且跑起來"><a href="#將-image-建立並且跑起來" class="headerlink" title="將 image 建立並且跑起來"></a>將 image 建立並且跑起來</h3><p>其實這個指令跟 <code>docker compose up</code> 蠻像的，差別在於他會強制 <code>build image</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker compose up --build</span><br></pre></td></tr></table></figure><p>什麼時候要用 <code>docker compose up</code> 什麼時候要用 <code>docker compose up --build</code> ?</p><p>我也被這兩個指令搞混蠻久的，總結是</p><p><img src="https://hackmd.io/_uploads/ryjPhpzfT.jpg"></p><p>當我們在包 image 的時候，就會用 <code>docker compose up --build</code> 讓他強制重新建立 image </p><p>而 <code>docker compose up</code> 會偵測到專案更新的時候，會 recreate container ，所以通常用在已經不會再去改 image 只有修改專案內容的時候</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前我們介紹了 Dockerfile 的基本指令，&lt;/p&gt;
&lt;p&gt;這次的主題我們要來介紹 docker-compose.yml &lt;/p&gt;
&lt;h3 id=&quot;關於-docker-compose-yml&quot;&gt;&lt;a href=&quot;#關於-docker-compose-yml&quot; clas</summary>
      
    
    
    
    <category term="Docker" scheme="http://ninglab.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>工程師都該懂的程式通識 - 語言的分類</title>
    <link href="http://ninglab.com/language/"/>
    <id>http://ninglab.com/language/</id>
    <published>2024-02-22T15:03:48.000Z</published>
    <updated>2024-02-23T17:41:07.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直譯語言與編譯語言"><a href="#直譯語言與編譯語言" class="headerlink" title="直譯語言與編譯語言"></a>直譯語言與編譯語言</h2><p><img src="https://hackmd.io/_uploads/BJh7Pbnzp.jpg"></p><h3 id="直譯語言是什麼？"><a href="#直譯語言是什麼？" class="headerlink" title="直譯語言是什麼？"></a>直譯語言是什麼？</h3><p>簡單來說不是使用編譯器來編譯，而是使用解釋器邊讀取邊執行，像是 Ruby、Python、JavaScript 都是直譯語言</p><p>編譯期：並沒有明確的編譯期，由直譯語言的解釋器 (Interpreter)<br>進行編譯，可以一邊讀取一邊執行，讀取完後會執行該程式碼，並且檢查語法，解釋器 (Interpreter)<br>像是口譯員，在讀取完完整的句子後，翻譯出來</p><p>執行期：解釋器(Interpreter)在執行期會將指令轉換為電腦能懂的語言，並且處理輸入、輸出，而這時候進行錯誤檢查，像是型別錯誤、定義變數的錯誤都會在這時候出現</p><h3 id="編譯語言是什麼？"><a href="#編譯語言是什麼？" class="headerlink" title="編譯語言是什麼？"></a>編譯語言是什麼？</h3><p>會先將程式碼編譯，再進行執行，像是 C、C#、JAVA 都是編譯語言</p><p>編譯期：由編譯器(Compiler)編譯成電腦看得懂的機器碼，這時期就會去檢查語法、型別等錯誤</p><p>執行期：這個階段會進行執行</p><h3 id="直譯語言與編譯語言的差異"><a href="#直譯語言與編譯語言的差異" class="headerlink" title="直譯語言與編譯語言的差異"></a>直譯語言與編譯語言的差異</h3><h4 id="效能"><a href="#效能" class="headerlink" title="效能"></a>效能</h4><p>編譯語言通常會先經過編譯期，事先把程式碼編譯好再執行，</p><p>不過直譯語言是邊讀取邊執行，所以在效能上，編譯語言會比直譯語言快。</p><h4 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h4><p>直譯語言在 Debug 的時候會方便許多，因為不需要修改再下指令要求編譯並執行，且可以提供更詳細的錯誤訊息</p><p>不過目前有些編譯語言也會提供詳細的錯誤訊息，像是 Rust ，不過一樣需要下指令才會讓程式碼重跑編譯期跟執行期</p><h2 id="動態語言跟靜態語言"><a href="#動態語言跟靜態語言" class="headerlink" title="動態語言跟靜態語言"></a>動態語言跟靜態語言</h2><p><img src="https://hackmd.io/_uploads/r1pBPW3f6.jpg"></p><h4 id="靜態語言"><a href="#靜態語言" class="headerlink" title="靜態語言"></a>靜態語言</h4><p>靜態語言指的是在編譯期間，型別就已經是已知且不會變動的，並且會在編譯期間檢查型別是否有誤，我們在編譯語言的編譯期可以看到型別錯誤的訊息，像是 Rust、C、C#、JAVA 都是靜態語言</p><h4 id="動態語言"><a href="#動態語言" class="headerlink" title="動態語言"></a>動態語言</h4><p>動態語言就跟靜態語言不一樣了，在執行的時候才會去檢查型別，表示變數的型別其實是可以在執行期變動的，像是 Ruby、PHP、JavaScript 都是動態語言</p><p>不過其實有些動態語言也支援編譯器，不過他們仍然被歸類在動態語言中，像是 Ruby 、Python 都可以將程式碼轉換成虛擬機器可以執行的程式碼</p><h2 id="高階語言與低階語言"><a href="#高階語言與低階語言" class="headerlink" title="高階語言與低階語言"></a>高階語言與低階語言</h2><p><img src="https://hackmd.io/_uploads/SJ2Uv-hMp.jpg"></p><p>而高階語言跟低階語言又是不同的分類，</p><h3 id="高階語言"><a href="#高階語言" class="headerlink" title="高階語言"></a>高階語言</h3><p>對於電腦來說比較抽象的語言，不過對開發人員來說是更富有易讀性，物件導向、高階資料結構這些都算是高階語言的特性</p><p>高階語言又根據特性分成以下類型</p><h4 id="通用程式語言"><a href="#通用程式語言" class="headerlink" title="通用程式語言"></a>通用程式語言</h4><p>用於處理各種不同類型的應用程式，可以適用網頁開發、軟體開發等多個領域，像是 Python、Java、C++、C#、Ruby、JavaScript</p><h4 id="腳本語言"><a href="#腳本語言" class="headerlink" title="腳本語言"></a>腳本語言</h4><p>通常用於簡化特定的指令、應用於自動化任務上，通常是直譯語言，像是 Python、JavaScript 等</p><h4 id="函數式語言"><a href="#函數式語言" class="headerlink" title="函數式語言"></a>函數式語言</h4><p>常用於大數據分析、數學運算，強調函數的不可變，像是 Haskell、Lisp、Scala、Erlang 等</p><h4 id="物件導向語言"><a href="#物件導向語言" class="headerlink" title="物件導向語言"></a>物件導向語言</h4><p>用物件來封裝，所應用到的大部分操作及變數都是物件，強調繼承概念，像是 Ruby、Java、C++、C#、Python 都是</p><h4 id="特定領域語言"><a href="#特定領域語言" class="headerlink" title="特定領域語言"></a>特定領域語言</h4><p>針對特定領域或任務所開發的語言，像是 HTML、SQL、CSS 都算是</p><h3 id="低階語言"><a href="#低階語言" class="headerlink" title="低階語言"></a>低階語言</h3><p>對於電腦來說更好閱讀的語言，對開發人員來說可能就沒這麼好閱讀，且開發人員需要注意記憶體管理，通常用於嵌入式系統開發、驅動程式開發，基本上是使用二進位形式</p><h4 id="組合語言"><a href="#組合語言" class="headerlink" title="組合語言"></a>組合語言</h4><p>相較二進位形式，更具有易讀性的語言，通常用符號來提高可讀性，可用來操作系統及驅動程式</p><h4 id="機器語言"><a href="#機器語言" class="headerlink" title="機器語言"></a>機器語言</h4><p>直接由 CPU 讀取及執行的指令，都是使用二進位形式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;直譯語言與編譯語言&quot;&gt;&lt;a href=&quot;#直譯語言與編譯語言&quot; class=&quot;headerlink&quot; title=&quot;直譯語言與編譯語言&quot;&gt;&lt;/a&gt;直譯語言與編譯語言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/BJh7P</summary>
      
    
    
    
    <category term="程式通識" scheme="http://ninglab.com/categories/%E7%A8%8B%E5%BC%8F%E9%80%9A%E8%AD%98/"/>
    
    
  </entry>
  
</feed>
