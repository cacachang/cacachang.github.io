<!DOCTYPE html><html lang="zh-TW"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Rails - Turbo 與 Turbo Drive · NingLab</title><meta name="description" content="Turbo瀏覽器的載入模式在 AJAX 還沒出現以前，使用者在瀏覽網頁，進行互動後，需要重新整理才會在網頁上看到互動後的結果

AJAX 模式AJAX 的全名為 Asynchronous JavaScript and XML ，這些字詞的意思為 非同步 JavaScript 與 XML
非同步 Ja"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4P2R013PGL"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4P2R013PGL')
</script><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.jpeg" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/ning.jpg" style="width:200px;"><h3 title=""><a href="/">NingLab</a></h3></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://twitter.com/ningchang_"><i class="fa fa-twitter"></i></a></li><li><a target="_blank" rel="noopener" href="https://github.com/cacachang"><i class="fa fa-github"></i></a></li><li><a href="mailto:a24701770@gmail.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="https://www.instagram.com/web543_/"><i class="fa fa-instagram"></i></a></li><li><a target="_blank" rel="noopener" href="https://www.linkedin.com/in/cacachang/"><i class="fa fa-linkedin"></i></a></li><li><a target="_blank" rel="noopener" href="https://www.youtube.com/channel/UCwRiNPzYITZWaif23HTmHZQ"><i class="fa fa-youtube"></i></a></li></ul><div class="footer"><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首頁</a></li><li><a href="/archives">文章</a></li><li><a href="/categories">目錄</a></li><li><a href="/about">關於 Ning</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.jpeg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Rails - Turbo 與 Turbo Drive</a></h3></div><div class="post-content"><h1 id="Turbo"><a href="#Turbo" class="headerlink" title="Turbo"></a>Turbo</h1><h2 id="瀏覽器的載入模式"><a href="#瀏覽器的載入模式" class="headerlink" title="瀏覽器的載入模式"></a>瀏覽器的載入模式</h2><p>在 AJAX 還沒出現以前，使用者在瀏覽網頁，進行互動後，需要重新整理才會在網頁上看到互動後的結果</p>
<p><img src="https://i.imgur.com/CFwObAB.jpeg"></p>
<h2 id="AJAX-模式"><a href="#AJAX-模式" class="headerlink" title="AJAX 模式"></a>AJAX 模式</h2><p>AJAX 的全名為 Asynchronous JavaScript and XML ，這些字詞的意思為 非同步 JavaScript 與 XML</p>
<p>非同步 JavaScript 大家應該都不陌生，指的是不需要等待上一個任務執行完再執行下一個，因此系統同時可以處理多個任務</p>
<p>而 AJAX 使用 XMLHttpRequest 來發送 Request，格式是採用 XML 格式</p>
<p>回傳的 Response 可以採用 XML 或者是 JSON ，現階段大多以 JSON 格式回傳</p>
<p><img src="https://i.imgur.com/vxXZ5xN.jpeg"></p>
<p>如此一來，就能馬上渲染資料</p>
<p><img src="https://i.imgur.com/h0MzwaM.gif" alt="giphy"></p>
<p>讓我們用 JS 的角度來看一下 AJAX 會是怎麼發送的，就會比較好理解 Turbo 的原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const button = document.getElementById(&quot;button&quot;)</span><br><span class="line"></span><br><span class="line">button.addEventListener(&#x27;click&#x27;, function()&#123;</span><br><span class="line">  let xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">  xhr.open(&#x27;GET&#x27;, &#x27;ajax.txt&#x27;, true);</span><br><span class="line"></span><br><span class="line">  xhr.send();</span><br><span class="line"></span><br><span class="line">  xhr.onload = function()&#123;</span><br><span class="line">    if (this.status == 200) &#123;</span><br><span class="line">      let text = document.getElementById(&quot;text&quot;)</span><br><span class="line">      text.innerHTML = this.responseText</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其實原理跟一般的事件監聽很像，<br>差別在於 <code>XMLHttpRequest</code> 會透過 url 來獲取資料，<br>而 <code>xhr.open</code> 第三個參數指的是是否採取同步或非同步，<br><code>true</code> 表示採取非同步</p>
<p>所以後續的程式碼都會一起執行，<br>並且及時地將拿回來的 Response 資料渲染</p>
<h2 id="關於-Turbo"><a href="#關於-Turbo" class="headerlink" title="關於 Turbo"></a>關於 Turbo</h2><p>Rails 透過 Turbo 來加速網頁的載入速度，</p>
<p>Turbo 是 AJAX 技術的應用，但他做的事會比 AJAX 更多</p>
<p>而 Turbo 又分成幾個功能</p>
<ol>
<li><p>Turbo Drive<br>加速載入頁面，讓使用者感受不到頁面之間的切換</p>
</li>
<li><p>Turbo Frame<br>不需要寫大量的 DOM 元素就能在同樣的頁面渲染表單或資訊</p>
</li>
<li><p>Turbo Stream<br>透過 Action Cable 即時渲染 Response 的內容</p>
</li>
<li><p>Turbo Native<br>用 Turbo 來打造 App (不過目前尚未設略，暫時不介紹)</p>
</li>
</ol>
<p>今天我們會先介紹 Turbo Drive</p>
<h2 id="關於-Turbo-Drive"><a href="#關於-Turbo-Drive" class="headerlink" title="關於 Turbo Drive"></a>關於 Turbo Drive</h2><p>Turbo Drive 就是以前的 Turbolinks</p>
<p>用 Rails 寫過專案的人應該多少都遇過在點擊連結的時候完全沒作用，是因為 Turbolinks 把所有的連結預設事件都停掉了，在 Rails 5 ~ Rails 6 版本的專案，我們可以用 <code>data-turbo=&quot;false&quot;</code> 來停掉連結的 Turbolinks</p>
<p>而在 Rails 7 中， Turbo Drive 不只將連結的預設事件停掉，連表單的預設事件也被停掉了，這樣做的目的是為了提高載入的速度！</p>
<p>只要掌握 Turbo Drive 的原理，它就會很好用！</p>
<h3 id="從-Visit-開始的生命週期"><a href="#從-Visit-開始的生命週期" class="headerlink" title="從 Visit 開始的生命週期"></a>從 Visit 開始的生命週期</h3><p>在使用者點擊的那一刻， Turbo Drive 的生命週期就開始了，一直到 render 完頁面才結束</p>
<p>Turbo Drive 在 render 的時候會做以下這幾件事情</p>
<ol>
<li>將 body 換成 Response 的 body</li>
<li>如果 head 的 title 以及 meta 改變，會將 head 合併，反之，head 將保持原樣</li>
<li>有需要的話會將 html 的 lang 標籤更新</li>
<li>除此之外，還會將 URL 更換掉</li>
</ol>
<p>Turbo 會有幾個生命週期，</p>
<p><code>turbo:click</code><br><code>turbo:before-visit</code><br><code>turbo:visit</code><br><code>turbo:before-cache</code><br><code>turbo:before-render</code><br><code>turbo:render</code><br><code>turbo:load</code></p>
<p>我們先來看前置作業，當點擊連結，並且拜訪 URL 以前，忙碌的 Turbo 做了哪些事</p>
<h3 id="session-visit-Turbo-開始"><a href="#session-visit-Turbo-開始" class="headerlink" title="session.visit - Turbo 開始"></a>session.visit - Turbo 開始</h3><p>當點擊時， Turbo 會先去判斷是否為 turbo frame，不是的話就會去拜訪該 URL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// src/core/session.js:97</span><br><span class="line"></span><br><span class="line">visit(location, options = &#123;&#125;) &#123;</span><br><span class="line">  const frameElement = options.frame ? document.getElementById(options.frame) : null</span><br><span class="line"></span><br><span class="line">  if (frameElement instanceof FrameElement) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.navigator.proposeVisit(expandURL(location), options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Navigator-停止預設事件"><a href="#Navigator-停止預設事件" class="headerlink" title="Navigator - 停止預設事件"></a>Navigator - 停止預設事件</h3><p>開始導去 URL 的時候，會先判斷該 URL 是否為同一頁，或者不同頁但是觸發 <code>turbo:before-visit</code> 事件，並且把預設事件停掉，就會開始接下來的訪問</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/navigator.js:12</span><br><span class="line"></span><br><span class="line">proposeVisit(location, options = &#123;&#125;) &#123;</span><br><span class="line">  if (this.delegate.allowsVisitingLocationWithAction(location, options.action)) &#123;</span><br><span class="line">    this.delegate.visitProposedToLocation(location, options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Session-開始拜訪"><a href="#Session-開始拜訪" class="headerlink" title="Session - 開始拜訪"></a>Session - 開始拜訪</h3><p>在這個階段會先將 URL 做新舊版本的轉換，避免舊版本無法支援(這邊的版本是指 Turbo Native 的 adapter)<br>接著就會請瀏覽器去拜訪了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// src/core/session.js:239</span><br><span class="line"></span><br><span class="line">visitProposedToLocation(location, options) &#123;</span><br><span class="line">  extendURLWithDeprecatedProperties(location)</span><br><span class="line">  this.adapter.visitProposedToLocation(location, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Browser-Adapter-拜訪前的敲門鈴確認"><a href="#Browser-Adapter-拜訪前的敲門鈴確認" class="headerlink" title="Browser Adapter - 拜訪前的敲門鈴確認"></a>Browser Adapter - 拜訪前的敲門鈴確認</h3><p>這時候 Turbo 會去確認 URL 的網域是不是一致的，一致才會繼續拜訪</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// src/core/native/browser_adapter.js:13</span><br><span class="line"></span><br><span class="line">visitProposedToLocation(location, options) &#123;</span><br><span class="line">  if (locationIsVisitable(location, this.navigator.rootLocation)) &#123;</span><br><span class="line">    this.navigator.startVisit(location, options?.restorationIdentifier || uuid(), options)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    window.location.href = location.toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Navigator-點下連結後的導向"><a href="#Navigator-點下連結後的導向" class="headerlink" title="Navigator - 點下連結後的導向"></a>Navigator - 點下連結後的導向</h3><p>在導向新的 URL 時，就會透過 expendURL 將 URL 設定成新的，不過不是在這邊換掉，是在 Visit 開始的時候才會換掉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/navigator.js:18</span><br><span class="line"></span><br><span class="line">startVisit(locatable, restorationIdentifier, options = &#123;&#125;) &#123;</span><br><span class="line">  this.stop()</span><br><span class="line">  this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, &#123;</span><br><span class="line">    referrer: this.location,</span><br><span class="line">    ...options</span><br><span class="line">  &#125;)</span><br><span class="line">  this.currentVisit.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// src/core/url.js:1</span><br><span class="line"></span><br><span class="line">export function expandURL(locatable) &#123;</span><br><span class="line">  return new URL(locatable.toString(), document.baseURI)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Visit-Turbo-Drive-開始生效"><a href="#Visit-Turbo-Drive-開始生效" class="headerlink" title="Visit - Turbo Drive 開始生效"></a>Visit - Turbo Drive 開始生效</h3><p>當確認好狀態為 <code>initialized</code> 並且定義完基本設定後，就會開始了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/visit.js:117</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">  if (this.state == VisitState.initialized) &#123;</span><br><span class="line">    this.recordTimingMetric(TimingMetric.visitStart)</span><br><span class="line">    this.state = VisitState.started</span><br><span class="line">    this.adapter.visitStarted(this)</span><br><span class="line">    this.delegate.visitStarted(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Browser-Adapter-改頭換面的開始"><a href="#Browser-Adapter-改頭換面的開始" class="headerlink" title="Browser Adapter - 改頭換面的開始"></a>Browser Adapter - 改頭換面的開始</h3><p>當開始 Visit 時，第一件事會將 URL 換掉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// src/core/native/browser_adapter.js:21</span><br><span class="line"></span><br><span class="line">visitStarted(visit) &#123;</span><br><span class="line">  this.location = visit.location</span><br><span class="line">  visit.loadCachedSnapshot()</span><br><span class="line">  visit.issueRequest()</span><br><span class="line">  visit.goToSamePageAnchor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著 Turbo Drive 需要判斷連結有沒有在 Cached 中，有的話就會直接渲染 Cached 中的頁面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/visit.js:247</span><br><span class="line"></span><br><span class="line">loadCachedSnapshot() &#123;</span><br><span class="line">  const snapshot = this.getCachedSnapshot()</span><br><span class="line">  if (snapshot) &#123;</span><br><span class="line">    const isPreview = this.shouldIssueRequest()</span><br><span class="line">    this.render(async () =&gt; &#123;</span><br><span class="line">      this.cacheSnapshot()</span><br><span class="line">      if (this.isSamePage || this.isPageRefresh) &#123;</span><br><span class="line">        this.adapter.visitRendered(this)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (this.view.renderPromise) await this.view.renderPromise</span><br><span class="line"></span><br><span class="line">        await this.renderPageSnapshot(snapshot, isPreview)</span><br><span class="line"></span><br><span class="line">        this.adapter.visitRendered(this)</span><br><span class="line">        if (!isPreview) &#123;</span><br><span class="line">          this.complete()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著會去看 Cached 是否已經有 Response ，<br>有的話就會模擬之前的 Request ，<br>沒有的話就會發送一個新的 Request</p>
<p>為什麼可以先載入 Response ，可參考此 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent/preloadResponse">MDN 的說明</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/visit.js:166</span><br><span class="line"></span><br><span class="line">issueRequest() &#123;</span><br><span class="line">  if (this.hasPreloadedResponse()) &#123;</span><br><span class="line">    this.simulateRequest()</span><br><span class="line">  &#125; else if (this.shouldIssueRequest() &amp;&amp; !this.request) &#123;</span><br><span class="line">    this.request = new FetchRequest(this, FetchMethod.get, this.location)</span><br><span class="line">    this.request.perform()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再來就是判斷新 URL 跟目前所在的頁面是否為同一頁，<br>同一頁的話就會挪到指定的 Anchor </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// src/core/drive/visit.js:281</span><br><span class="line"></span><br><span class="line">  goToSamePageAnchor() &#123;</span><br><span class="line">    if (this.isSamePage) &#123;</span><br><span class="line">      this.render(async () =&gt; &#123;</span><br><span class="line">        this.cacheSnapshot()</span><br><span class="line">        this.performScroll()</span><br><span class="line">        this.changeHistory()</span><br><span class="line">        this.adapter.visitRendered(this)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Session-拜訪"><a href="#Session-拜訪" class="headerlink" title="Session - 拜訪"></a>Session - 拜訪</h3><p>接著</p>
<p>假設目前的 Visit 並沒有接受 Stream 格式的 Response ，就將它標記為正在處理中，這個處理可能是在處理 Request 以及換頁，</p>
<p>總之，不是以 Turbo Drive 的方式去處理</p>
<p>接著會判斷是在看是不是為同一頁，同一頁的話就會觸發 <code>turbo:visit</code> 並訪問該 URL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// src/core/session.js:246</span><br><span class="line"></span><br><span class="line">  visitStarted(visit) &#123;</span><br><span class="line">    if (!visit.acceptsStreamResponse) &#123;</span><br><span class="line">      markAsBusy(document.documentElement)</span><br><span class="line">      this.view.markVisitDirection(visit.direction)</span><br><span class="line">    &#125;</span><br><span class="line">    extendURLWithDeprecatedProperties(visit.location)</span><br><span class="line">    if (!visit.silent) &#123;</span><br><span class="line">      this.notifyApplicationAfterVisitingLocation(visit.location, visit.action)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>以上只是渲染之前所做的事情 ( 實際上要處理的應該遠比我提的更多，我這邊只先提個大致的流程 )</p>
<h3 id="不同的-Visit"><a href="#不同的-Visit" class="headerlink" title="不同的 Visit"></a>不同的 Visit</h3><p>Turbo Drive 又分成兩種 Visit</p>
<p>一種是 <code>Application Visits</code> ，另一種是 <code>Restoration Visits</code></p>
<p>在這之前我們可以來了解一下 Turbo Drive 處理 Cached 的機制</p>
<p>Turbo Drive 會將最近造訪過的 URL 暫存，有兩個目的</p>
<ol>
<li>在歷史紀錄中切換 URL ( 即所謂的 Restoration Visits  ) 的時候，不需要發送 Request 就能渲染</li>
<li>在一般的 URL 切換中，能快速渲染頁面(但還是會發送 Request)，讓使用者感受不到有在切換</li>
</ol>
<p>Application Visits 將會發送 Request ，並且如果 Cached 有該 URL 頁面資訊的話，就會渲染頁面資訊</p>
<p>Restoration Visits<br>使用者點擊了瀏覽器的上一頁，或是下一頁，因為已經瀏覽過， Cached 中可能會有資料，所以就不會發送 Request ，而是直接 render Cached 裡面的頁面資訊</p>
<p>上述兩種 Visit 最大的差別應該是在於是否為歷史紀錄中的切換以及是否有發送 Request</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2024-03-04</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Rails/" title="Rails">Rails </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://ninglab.com/Rails-Turbo-and-Turbo Drive/,NingLab,Rails - Turbo 與 Turbo Drive,;"></a></div></div><div><script src="https://utteranc.es/client.js" repo="cacachang/cacachang.github.io" issue-term="title" theme="github-light" crossorigin="anonymous" async></script></div><div><script type="text/javascript">document.write("<iframe scrolling='no' frameborder='0' sandbox='allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox allow-storage-access-by-user-activation' style='height: 212px; width: 100%;' src='https://button.like.co/in/embed/a24701770/button?referrer=" + encodeURIComponent(location.href.split("?")[0].split("#")[0]) + "'></iframe>");</script></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/JavaScript-execution-context-1/" title="JavaScript - 運行背後的世界(1)">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/proxy/" title="工程師都該懂的程式通識 - Proxy">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>